{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydaadop","text":"<p>Documentation for development version: bc042b5.</p> <p>Python dockerized api and database on pydantic (Pydaadop) is a library for Python for automatic wrapper generation for APIs and databases. It is designed to be simple and fast and integrates with the FastAPI framework.</p>"},{"location":"#why-use-pydaadop","title":"Why use Pydaadop?","text":"<p>Installing Pydaadop is as simple as: <code>pip install pydaadop</code></p>"},{"location":"#who-is-using-pydaadop","title":"Who is using Pydaadop?","text":"<p>No one is using it :(</p> <p>For a more comprehensive list of open-source projects using Pydaadop see the list of dependents on github.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We'd love you to contribute to Pydantic!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues. However, to report a security vulnerability, please see our security policy.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <p><pre><code>python -c \"import pydantic.version; print(pydantic.version.version_info())\"\n</code></pre> If you're using Pydantic prior to v2.0 please use: <pre><code>python -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n</code></pre></p> <p>Please try to always include the above unless you're unable to install Pydantic or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. Pydantic is released regularly so you should see your improvements release in a matter of days or weeks \ud83d\ude80.</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>Pydantic V1 is in maintenance mode</p> <p>Pydantic v1 is in maintenance mode, meaning that only bug fixes and security fixes will be accepted. New features should be targeted at Pydantic v2.</p> <p>To submit a fix to Pydantic v1, use the <code>1.10.X-fixes</code> as a target branch.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, Pydantic has few dependencies, doesn't require compiling and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>Tip</p> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting and <code>make docs</code> to build the docs.</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>You'll need the following prerequisites:</p> <ul> <li>Any Python version between Python 3.9 and 3.12</li> <li>uv or other virtual environment tool</li> <li>git</li> <li>make</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and setup","text":"<p>Fork the repository on GitHub and clone your fork locally.</p> <pre><code># Clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/pydantic.git\ncd pydantic\n\n# Install UV and pre-commit\n# We use pipx here, for other options see:\n# https://docs.astral.sh/uv/getting-started/installation/\n# https://pre-commit.com/#install\n# To get pipx itself:\n# https://pypa.github.io/pipx/\npipx install uv\npipx install pre-commit\n\n# Install pydantic, dependencies, test dependencies and doc dependencies\nmake install\n</code></pre>"},{"location":"contributing/#check-out-a-new-branch-and-make-your-changes","title":"Check out a new branch and make your changes","text":"<p>Create a new branch for your changes.</p> <pre><code># Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# Make your changes...\n</code></pre>"},{"location":"contributing/#run-tests-and-linting","title":"Run tests and linting","text":"<p>Run tests and linting locally to make sure everything is working as expected.</p> <pre><code># Run automated code formatting and linting\nmake format\n# Pydantic uses ruff, an awesome Python linter written in rust\n# https://github.com/astral-sh/ruff\n\n# Run tests and linting\nmake\n# There are a few sub-commands in Makefile like `test`, `testcov` and `lint`\n# which you might want to use, but generally just `make` should be all you need.\n# You can run `make help` to see more options.\n</code></pre>"},{"location":"contributing/#build-documentation","title":"Build documentation","text":"<p>If you've made any changes to the documentation (including changes to function signatures, class definitions, or docstrings that will appear in the API documentation), make sure it builds successfully.</p> <p>We use <code>mkdocs-material[imaging]</code> to support social previews. You can find directions on how to install the required dependencies here.</p> <pre><code># Build documentation\nmake docs\n# If you have changed the documentation, make sure it builds successfully.\n# You can also use `uv run mkdocs serve` to serve the documentation at localhost:8000\n</code></pre> <p>If this isn't working due to issues with the imaging plugin, try commenting out the <code>social</code> plugin line in <code>mkdocs.yml</code> and running <code>make docs</code> again.</p>"},{"location":"contributing/#updating-the-documentation","title":"Updating the documentation","text":"<p>We push a new version of the documentation with each minor release, and we push to a <code>dev</code> path with each commit to <code>main</code>.</p> <p>If you're updating the documentation out of cycle with a minor release and want your changes to be reflected on <code>latest</code>, do the following:</p> <ol> <li>Open a PR against <code>main</code> with your docs changes</li> <li>Once the PR is merged, checkout the <code>docs-update</code> branch. This branch should be up to date with the latest patch release. For example, if the latest release is <code>v2.9.2</code>, you should make sure <code>docs-update</code> is up to date with the <code>v2.9.2</code> tag.</li> <li>Checkout a new branch from <code>docs-update</code> and cherry-pick your changes onto this branch.</li> <li>Push your changes and open a PR against <code>docs-update</code>.</li> <li>Once the PR is merged, the new docs will be built and deployed.</li> </ol> <p>Note</p> <p>Maintainer shortcut - as a maintainer, you can skip the second PR and just cherry pick directly onto the <code>docs-update</code> branch.</p>"},{"location":"contributing/#commit-and-push-your-changes","title":"Commit and push your changes","text":"<p>Commit your changes, push your branch to GitHub, and create a pull request.</p> <p>Please follow the pull request template and fill in as much information as possible. Link to any relevant issues and include a description of your changes.</p> <p>When your pull request is ready for review, add a comment with the message \"please review\" and we'll take a look as soon as we can.</p>"},{"location":"contributing/#documentation-style","title":"Documentation style","text":"<p>Documentation is written in Markdown and built using Material for MkDocs. API documentation is build from docstrings using mkdocstrings.</p>"},{"location":"contributing/#code-documentation","title":"Code documentation","text":"<p>When contributing to Pydantic, please make sure that all code is well documented. The following should be documented using properly formatted docstrings:</p> <ul> <li>Modules</li> <li>Class definitions</li> <li>Function definitions</li> <li>Module-level variables</li> </ul> <p>Pydantic uses Google-style docstrings formatted according to PEP 257 guidelines. (See Example Google Style Python Docstrings for further examples.)</p> <p>pydocstyle is used for linting docstrings. You can run <code>make format</code> to check your docstrings.</p> <p>Where this is a conflict between Google-style docstrings and pydocstyle linting, follow the pydocstyle linting hints.</p> <p>Class attributes and function arguments should be documented in the format \"name: description.\" When applicable, a return type should be documented with just a description. Types are inferred from the signature.</p> <pre><code>class Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n</code></pre> <pre><code>def bar(self, baz: int) -&gt; str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n</code></pre> <p>You may include example code in docstrings. This code should be complete, self-contained, and runnable. Docstring examples are tested, so make sure they are correct and complete.</p> <p>Class and instance attributes</p> <p>Class attributes should be documented in the class docstring.</p> <p>Instance attributes should be documented as \"Args\" in the <code>__init__</code> docstring.</p>"},{"location":"contributing/#documentation-style_1","title":"Documentation Style","text":"<p>In general, documentation should be written in a friendly, approachable style. It should be easy to read and understand, and should be as concise as possible while still being complete.</p> <p>Code examples are encouraged, but should be kept short and simple. However, every code example should be complete, self-contained, and runnable. (If you're not sure how to do this, ask for help!) We prefer print output to naked asserts, but if you're testing something that doesn't have a useful print output, asserts are fine.</p> <p>Pydantic's unit test will test all code examples in the documentation, so it's important that they are correct and complete. When adding a new code example, use the following to test examples and update their formatting and output:</p> <pre><code># Run tests and update code examples\npytest tests/test_docs.py --update-examples\n</code></pre>"},{"location":"contributing/#debugging-python-and-rust","title":"Debugging Python and Rust","text":"<p>If you're working with <code>pydantic</code> and <code>pydantic-core</code>, you might find it helpful to debug Python and Rust code together. Here's a quick guide on how to do that. This tutorial is done in VSCode, but you can use similar steps in other IDEs.</p>"},{"location":"contributing/#badges","title":"Badges","text":"<p>Pydantic has a badge that you can use to show that your project uses Pydantic. You can use this badge in your <code>README.md</code>:</p>"},{"location":"contributing/#with-markdown","title":"With Markdown","text":"<pre><code>[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n</code></pre>"},{"location":"contributing/#with-restructuredtext","title":"With reStructuredText","text":"<pre><code>.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n</code></pre>"},{"location":"contributing/#with-html","title":"With HTML","text":"<pre><code>&lt;a href=\"https://pydantic.dev\"&gt;&lt;img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"&gt;&lt;/a&gt;\n\n&lt;a href=\"https://pydantic.dev\"&gt;&lt;img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"&gt;&lt;/a&gt;\n</code></pre>"},{"location":"install/","title":"Installation","text":"<p>Installation is as simple as:</p> pipuv <pre><code>pip install pydaadop\n</code></pre> <pre><code>uv add pydaadop\n</code></pre> <p>Pydaadop has a few dependencies:</p> <ul> <li><code>pydantic-core</code>: Core validation logic for Pydantic written in Rust.</li> <li><code>typing-extensions</code>: Backport of the standard library typing module.</li> <li><code>annotated-types</code>: Reusable constraint types to use with <code>typing.Annotated</code>.</li> </ul> <p>If you've got Python 3.9+ and <code>pip</code> installed, you're good to go.</p>"},{"location":"install/#install-from-repository","title":"Install from repository","text":"<p>And if you prefer to install Pydaadop directly from the repository:</p> pipuv <pre><code>pip install 'git+https://github.com/vanthomiy/pydaadop@main'\n</code></pre> <pre><code>uv add 'git+https://github.com/vanthomiy/pydaadop@main'\n</code></pre>"},{"location":"api/api_clients/base_api_client/","title":"base_api_client","text":""},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient","title":"BaseApiClient","text":"<pre><code>BaseApiClient(base_url: str, model_class: Type[T], headers: Dict[str, str] = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A base client for performing API operations on a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the API.</p> required <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the requests.</p> <code>None</code> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def __init__(self, base_url: str, model_class: Type[T], headers: Dict[str, str] = None):\n    self.base_url = base_url\n    self.model_class = model_class\n    self.headers = headers or {}\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.model_class","title":"model_class  <code>instance-attribute</code>","text":"<pre><code>model_class = model_class\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers = headers or {}\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient._request","title":"_request","text":"<pre><code>_request(method: str, endpoint: str, **kwargs: dict) -&gt; Union[Dict[str, Any], List[Dict[str, Any]]]\n</code></pre> <p>Sends a request to the API.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use.</p> required <code>endpoint</code> <code>str</code> <p>The API endpoint.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments for the request.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Dict[str, Any], List[Dict[str, Any]]]</code> <p>Union[Dict[str, Any], List[Dict[str, Any]]]: The response data from the API.</p> Example <p>response = self._request(\"GET\", \"my_model\")</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def _request(self, method: str, endpoint: str, **kwargs: dict) -&gt; Union[Dict[str, Any], List[Dict[str, Any]]]:\n    \"\"\"\n    Sends a request to the API.\n\n    Args:\n        method (str): The HTTP method to use.\n        endpoint (str): The API endpoint.\n        **kwargs: Additional arguments for the request.\n\n    Returns:\n        Union[Dict[str, Any], List[Dict[str, Any]]]: The response data from the API.\n\n    Example:\n        response = self._request(\"GET\", \"my_model\")\n    \"\"\"\n    url = f\"{self.base_url}/{endpoint}/\"\n    response: Response = request(method, url, headers=self.headers, **kwargs)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.parse_query","title":"parse_query  <code>classmethod</code>","text":"<pre><code>parse_query(select_query: Optional[BaseSelect] = None, paging_query: Optional[BasePaging] = None, filter_query: Optional[Dict[str, Any]] = None, sort_query: Optional[BaseSort] = None, search_query: Optional[Dict[str, Any]] = None, range_query: Optional[BaseRange] = None, key_filter_query: Optional[Dict[str, Any]] = None, list_filter: Optional[BaseListFilter] = None) -&gt; dict[str, Any]\n</code></pre> <p>Parses various query parameters into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>select_query</code> <code>Optional[BaseSelect]</code> <p>The select query parameters.</p> <code>None</code> <code>paging_query</code> <code>Optional[BasePaging]</code> <p>The paging query parameters.</p> <code>None</code> <code>filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The filter query parameters.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query parameters.</p> <code>None</code> <code>search_query</code> <code>Optional[Dict[str, Any]]</code> <p>The search query parameters.</p> <code>None</code> <code>range_query</code> <code>Optional[BaseRange]</code> <p>The range query parameters.</p> <code>None</code> <code>key_filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The key filter query parameters.</p> <code>None</code> <code>list_filter</code> <code>Optional[BaseListFilter]</code> <p>The list filter query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The parsed query parameters.</p> Example <p>params = self.parse_query(filter_query={\"name\": \"example\"})</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>@classmethod\ndef parse_query(cls,\n            select_query: Optional[BaseSelect] = None,\n            paging_query: Optional[BasePaging] = None,\n            filter_query: Optional[Dict[str, Any]] = None,\n            sort_query: Optional[BaseSort] = None,\n            search_query: Optional[Dict[str, Any]] = None,\n            range_query: Optional[BaseRange] = None,\n            key_filter_query: Optional[Dict[str, Any]] = None,\n            list_filter: Optional[BaseListFilter] = None) -&gt; dict[str, Any]:\n    \"\"\"\n    Parses various query parameters into a dictionary.\n\n    Args:\n        select_query (Optional[BaseSelect]): The select query parameters.\n        paging_query (Optional[BasePaging]): The paging query parameters.\n        filter_query (Optional[Dict[str, Any]]): The filter query parameters.\n        sort_query (Optional[BaseSort]): The sort query parameters.\n        search_query (Optional[Dict[str, Any]]): The search query parameters.\n        range_query (Optional[BaseRange]): The range query parameters.\n        key_filter_query (Optional[Dict[str, Any]]): The key filter query parameters.\n        list_filter (Optional[BaseListFilter]): The list filter query parameters.\n\n    Returns:\n        dict[str, Any]: The parsed query parameters.\n\n    Example:\n        params = self.parse_query(filter_query={\"name\": \"example\"})\n    \"\"\"\n    _params: Dict[str, Any] = {}\n\n    if paging_query:\n        _params.update(paging_query.model_dump())\n    if filter_query:\n        _params.update(filter_query)\n    if key_filter_query:\n        _params.update(key_filter_query)\n    if search_query:\n        _params.update(search_query)\n    if list_filter:\n        _params.update(list_filter.to_mongo_filter())\n    if sort_query:\n        _params.update(sort_query.model_dump())\n    if select_query:\n        _params.update(select_query.model_dump())\n    if range_query:\n        _params.update(range_query.model_dump())\n\n    _params = {k: v for k, v in _params.items() if v is not None}\n\n    return _params\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.get_query_info","title":"get_query_info","text":"<pre><code>get_query_info() -&gt; Dict[str, Any]\n</code></pre> <p>Retrieves query information for the model.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The query information.</p> Example <p>query_info = self.get_query_info()</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def get_query_info(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves query information for the model.\n\n    Returns:\n        Dict[str, Any]: The query information.\n\n    Example:\n        query_info = self.get_query_info()\n    \"\"\"\n    return self._request(\"GET\", f\"{self.model_class.__name__.lower()}/display-info/query\")\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.get_display_info","title":"get_display_info","text":"<pre><code>get_display_info(filter_query: Optional[Dict[str, Any]] = None, search_query: Optional[Dict[str, Any]] = None, range_query: Optional[BaseRange] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Retrieves display information for the model.</p> <p>Parameters:</p> Name Type Description Default <code>filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The filter query parameters.</p> <code>None</code> <code>search_query</code> <code>Optional[Dict[str, Any]]</code> <p>The search query parameters.</p> <code>None</code> <code>range_query</code> <code>Optional[BaseRange]</code> <p>The range query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The display information.</p> Example <p>display_info = self.get_display_info(filter_query={\"name\": \"example\"})</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def get_display_info(self, filter_query: Optional[Dict[str, Any]] = None, search_query: Optional[Dict[str, Any]] = None, range_query: Optional[BaseRange] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves display information for the model.\n\n    Args:\n        filter_query (Optional[Dict[str, Any]]): The filter query parameters.\n        search_query (Optional[Dict[str, Any]]): The search query parameters.\n        range_query (Optional[BaseRange]): The range query parameters.\n\n    Returns:\n        Dict[str, Any]: The display information.\n\n    Example:\n        display_info = self.get_display_info(filter_query={\"name\": \"example\"})\n    \"\"\"\n    _params = self.parse_query(None, None, filter_query, None, search_query, range_query)\n    return self._request(\"GET\", f\"{self.model_class.__name__.lower()}/display-info/item\", params=_params)\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.get_all","title":"get_all","text":"<pre><code>get_all(paging_query: Optional[BasePaging] = None, filter_query: Optional[Dict[str, Any]] = None, sort_query: Optional[BaseSort] = None, search_query: Optional[Dict[str, Any]] = None, range_query: Optional[BaseRange] = None, list_filter: Optional[BaseListFilter] = None) -&gt; List[T]\n</code></pre> <p>Retrieves all items of the model.</p> <p>Parameters:</p> Name Type Description Default <code>paging_query</code> <code>Optional[BasePaging]</code> <p>The paging query parameters.</p> <code>None</code> <code>filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The filter query parameters.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query parameters.</p> <code>None</code> <code>search_query</code> <code>Optional[Dict[str, Any]]</code> <p>The search query parameters.</p> <code>None</code> <code>range_query</code> <code>Optional[BaseRange]</code> <p>The range query parameters.</p> <code>None</code> <code>list_filter</code> <code>Optional[BaseListFilter]</code> <p>The list filter query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>List[T]: The list of items.</p> Example <p>items = self.get_all(filter_query={\"name\": \"example\"})</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def get_all(self,\n            paging_query: Optional[BasePaging] = None,\n            filter_query: Optional[Dict[str, Any]] = None,\n            sort_query: Optional[BaseSort] = None,\n            search_query: Optional[Dict[str, Any]] = None,\n            range_query: Optional[BaseRange] = None,\n            list_filter: Optional[BaseListFilter] = None) -&gt; List[T]:\n    \"\"\"\n    Retrieves all items of the model.\n\n    Args:\n        paging_query (Optional[BasePaging]): The paging query parameters.\n        filter_query (Optional[Dict[str, Any]]): The filter query parameters.\n        sort_query (Optional[BaseSort]): The sort query parameters.\n        search_query (Optional[Dict[str, Any]]): The search query parameters.\n        range_query (Optional[BaseRange]): The range query parameters.\n        list_filter (Optional[BaseListFilter]): The list filter query parameters.\n\n    Returns:\n        List[T]: The list of items.\n\n    Example:\n        items = self.get_all(filter_query={\"name\": \"example\"})\n    \"\"\"\n    _params = self.parse_query(None, paging_query, filter_query, sort_query, search_query, range_query, list_filter)\n\n    data = self._request(\"GET\", f\"{self.model_class.__name__.lower()}\", params=_params)\n    return [self.model_class(**item) for item in data]\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.get_all_select","title":"get_all_select","text":"<pre><code>get_all_select(select_query: Optional[BaseSelect] = None, paging_query: Optional[BasePaging] = None, filter_query: Optional[Dict[str, Any]] = None, sort_query: Optional[BaseSort] = None, search_query: Optional[Dict[str, Any]] = None, range_query: Optional[BaseRange] = None, list_filter: Optional[BaseListFilter] = None) -&gt; List[Dict]\n</code></pre> <p>Retrieves all items of the model with selected fields.</p> <p>Parameters:</p> Name Type Description Default <code>select_query</code> <code>Optional[BaseSelect]</code> <p>The select query parameters.</p> <code>None</code> <code>paging_query</code> <code>Optional[BasePaging]</code> <p>The paging query parameters.</p> <code>None</code> <code>filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The filter query parameters.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query parameters.</p> <code>None</code> <code>search_query</code> <code>Optional[Dict[str, Any]]</code> <p>The search query parameters.</p> <code>None</code> <code>range_query</code> <code>Optional[BaseRange]</code> <p>The range query parameters.</p> <code>None</code> <code>list_filter</code> <code>Optional[BaseListFilter]</code> <p>The list filter query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: The list of items with selected fields.</p> Example <p>items = self.get_all_select(select_query=BaseSelect(fields=[\"name\"]))</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def get_all_select(self,\n            select_query: Optional[BaseSelect] = None,\n            paging_query: Optional[BasePaging] = None,\n            filter_query: Optional[Dict[str, Any]] = None,\n            sort_query: Optional[BaseSort] = None,\n            search_query: Optional[Dict[str, Any]] = None,\n            range_query: Optional[BaseRange] = None,\n            list_filter: Optional[BaseListFilter] = None) -&gt; List[Dict]:\n    \"\"\"\n    Retrieves all items of the model with selected fields.\n\n    Args:\n        select_query (Optional[BaseSelect]): The select query parameters.\n        paging_query (Optional[BasePaging]): The paging query parameters.\n        filter_query (Optional[Dict[str, Any]]): The filter query parameters.\n        sort_query (Optional[BaseSort]): The sort query parameters.\n        search_query (Optional[Dict[str, Any]]): The search query parameters.\n        range_query (Optional[BaseRange]): The range query parameters.\n        list_filter (Optional[BaseListFilter]): The list filter query parameters.\n\n    Returns:\n        List[Dict]: The list of items with selected fields.\n\n    Example:\n        items = self.get_all_select(select_query=BaseSelect(fields=[\"name\"]))\n    \"\"\"\n    _params = self.parse_query(select_query, paging_query, filter_query, sort_query, search_query, range_query, list_filter)\n\n    data = self._request(\"GET\", f\"{self.model_class.__name__.lower()}/select\", params=_params)\n    return data\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.exists","title":"exists","text":"<pre><code>exists(key_filter_query: Optional[Dict[str, Any]]) -&gt; bool\n</code></pre> <p>Checks if an item exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The key filter query parameters.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item exists, False otherwise.</p> Example <p>exists = self.exists(key_filter_query={\"id\": \"example_id\"})</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def exists(self, key_filter_query: Optional[Dict[str, Any]]) -&gt; bool:\n    \"\"\"\n    Checks if an item exists in the database.\n\n    Args:\n        key_filter_query (Optional[Dict[str, Any]]): The key filter query parameters.\n\n    Returns:\n        bool: True if the item exists, False otherwise.\n\n    Example:\n        exists = self.exists(key_filter_query={\"id\": \"example_id\"})\n    \"\"\"\n    _params = self.parse_query(key_filter_query=key_filter_query)\n    data = self._request(\"GET\", f\"{self.model_class.__name__.lower()}/exists\", params=_params)\n    return bool(**data)\n</code></pre>"},{"location":"api/api_clients/base_api_client/#pydaadop.api_clients.base_api_client.BaseApiClient.get","title":"get","text":"<pre><code>get(key_filter_query: Optional[Dict[str, Any]]) -&gt; T\n</code></pre> <p>Retrieves a single item from the database.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The key filter query parameters.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The retrieved item.</p> Example <p>item = self.get(key_filter_query={\"id\": \"example_id\"})</p> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def get(self, key_filter_query: Optional[Dict[str, Any]]) -&gt; T:\n    \"\"\"\n    Retrieves a single item from the database.\n\n    Args:\n        key_filter_query (Optional[Dict[str, Any]]): The key filter query parameters.\n\n    Returns:\n        T: The retrieved item.\n\n    Example:\n        item = self.get(key_filter_query={\"id\": \"example_id\"})\n    \"\"\"\n    _params = self.parse_query(key_filter_query=key_filter_query)\n    data = self._request(\"GET\", f\"{self.model_class.__name__.lower()}/item\", params=_params)\n    return self.model_class(**data)\n</code></pre>"},{"location":"api/api_clients/client_api_factory/","title":"client_api_factory","text":""},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory","title":"ClientFactory","text":"<pre><code>ClientFactory(base_url: str, headers: Dict[str, str] = None)\n</code></pre> <p>A factory for creating API clients for different models.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the API.</p> required <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the requests.</p> <code>None</code> Source code in <code>src/pydaadop/api_clients/client_api_factory.py</code> <pre><code>def __init__(self, base_url: str, headers: Dict[str, str] = None):\n    self.base_url = base_url\n    self.headers = headers\n    self.clients: Dict[Type[BaseMongoModel], BaseApiClient] = {}\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers = headers\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.clients","title":"clients  <code>instance-attribute</code>","text":"<pre><code>clients: Dict[Type[BaseMongoModel], BaseApiClient] = {}\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.get_read_client","title":"get_read_client","text":"<pre><code>get_read_client(model_class: Type[T]) -&gt; ReadApiClient[T]\n</code></pre> <p>Returns a read client for the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <p>Returns:</p> Type Description <code>ReadApiClient[T]</code> <p>ReadApiClient[T]: The read client for the specified model.</p> Example <p>factory = ClientFactory(\"http://localhost:8000/\") read_client = factory.get_read_client(MyModel)</p> Source code in <code>src/pydaadop/api_clients/client_api_factory.py</code> <pre><code>def get_read_client(self, model_class: Type[T]) -&gt; ReadApiClient[T]:\n    \"\"\"\n    Returns a read client for the specified model.\n\n    Args:\n        model_class (Type[T]): The model class to be used.\n\n    Returns:\n        ReadApiClient[T]: The read client for the specified model.\n\n    Example:\n        factory = ClientFactory(\"http://localhost:8000/\")\n        read_client = factory.get_read_client(MyModel)\n    \"\"\"\n    if model_class not in self.clients:\n        self.clients[model_class] = ReadApiClient(self.base_url, model_class, self.headers)\n    return cast(ReadApiClient[T], self.clients[model_class])\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.get_read_write_client","title":"get_read_write_client","text":"<pre><code>get_read_write_client(model_class: Type[T]) -&gt; ReadWriteApiClient[T]\n</code></pre> <p>Returns a read-write client for the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <p>Returns:</p> Type Description <code>ReadWriteApiClient[T]</code> <p>ReadWriteApiClient[T]: The read-write client for the specified model.</p> Example <p>factory = ClientFactory(\"http://localhost:8000/\") read_write_client = factory.get_read_write_client(MyModel)</p> Source code in <code>src/pydaadop/api_clients/client_api_factory.py</code> <pre><code>def get_read_write_client(self, model_class: Type[T]) -&gt; ReadWriteApiClient[T]:\n    \"\"\"\n    Returns a read-write client for the specified model.\n\n    Args:\n        model_class (Type[T]): The model class to be used.\n\n    Returns:\n        ReadWriteApiClient[T]: The read-write client for the specified model.\n\n    Example:\n        factory = ClientFactory(\"http://localhost:8000/\")\n        read_write_client = factory.get_read_write_client(MyModel)\n    \"\"\"\n    if model_class not in self.clients:\n        self.clients[model_class] = ReadWriteApiClient(self.base_url, model_class, self.headers)\n    return cast(ReadWriteApiClient[T], self.clients[model_class])\n</code></pre>"},{"location":"api/api_clients/client_api_factory/#pydaadop.api_clients.client_api_factory.ClientFactory.get_many_read_write_client","title":"get_many_read_write_client","text":"<pre><code>get_many_read_write_client(model_class: Type[T]) -&gt; ManyReadWriteApiClient[T]\n</code></pre> <p>Returns a many read-write client for the specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <p>Returns:</p> Type Description <code>ManyReadWriteApiClient[T]</code> <p>ManyReadWriteApiClient[T]: The many read-write client for the specified model.</p> Example <p>factory = ClientFactory(\"http://localhost:8000/\") many_read_write_client = factory.get_many_read_write_client(MyModel)</p> Source code in <code>src/pydaadop/api_clients/client_api_factory.py</code> <pre><code>def get_many_read_write_client(self, model_class: Type[T]) -&gt; ManyReadWriteApiClient[T]:\n    \"\"\"\n    Returns a many read-write client for the specified model.\n\n    Args:\n        model_class (Type[T]): The model class to be used.\n\n    Returns:\n        ManyReadWriteApiClient[T]: The many read-write client for the specified model.\n\n    Example:\n        factory = ClientFactory(\"http://localhost:8000/\")\n        many_read_write_client = factory.get_many_read_write_client(MyModel)\n    \"\"\"\n    if model_class not in self.clients:\n        self.clients[model_class] = ManyReadWriteApiClient(self.base_url, model_class, self.headers)\n    return cast(ManyReadWriteApiClient[T], self.clients[model_class])\n</code></pre>"},{"location":"api/api_clients/many_read_write_api_client/","title":"many_read_write_api_client","text":""},{"location":"api/api_clients/many_read_write_api_client/#pydaadop.api_clients.many_read_write_api_client.ManyReadWriteApiClient","title":"ManyReadWriteApiClient","text":"<pre><code>ManyReadWriteApiClient(base_url: str, model_class: Type[T], headers: Dict[str, str] = None)\n</code></pre> <p>               Bases: <code>ReadWriteApiClient[T]</code></p> <p>A client for performing batch read and write operations on a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the API.</p> required <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the requests.</p> <code>None</code> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def __init__(self, base_url: str, model_class: Type[T], headers: Dict[str, str] = None):\n    self.base_url = base_url\n    self.model_class = model_class\n    self.headers = headers or {}\n</code></pre>"},{"location":"api/api_clients/many_read_write_api_client/#pydaadop.api_clients.many_read_write_api_client.ManyReadWriteApiClient.insert_many","title":"insert_many","text":"<pre><code>insert_many(items: List[T]) -&gt; Dict\n</code></pre> <p>Inserts multiple items into the database.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The items to be inserted.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The response data from the database.</p> Example <p>items = [MyModel(name=\"example1\"), MyModel(name=\"example2\")] response = client.insert_many(items)</p> Source code in <code>src/pydaadop/api_clients/many_read_write_api_client.py</code> <pre><code>def insert_many(self, items: List[T]) -&gt; Dict:\n    \"\"\"\n    Inserts multiple items into the database.\n\n    Args:\n        items (List[T]): The items to be inserted.\n\n    Returns:\n        Dict: The response data from the database.\n\n    Example:\n        items = [MyModel(name=\"example1\"), MyModel(name=\"example2\")]\n        response = client.insert_many(items)\n    \"\"\"\n    if not items or len(items) == 0:\n        return {}\n    endpoint = self.model_class.__name__.lower() + \"-insert-many\"\n    dict_items = [item.model_dump() for item in items]\n    response_data = self._request(\"POST\", endpoint, json=dict_items)\n    return response_data\n</code></pre>"},{"location":"api/api_clients/many_read_write_api_client/#pydaadop.api_clients.many_read_write_api_client.ManyReadWriteApiClient.update_many","title":"update_many","text":"<pre><code>update_many(items: List[T]) -&gt; Dict\n</code></pre> <p>Updates multiple items in the database.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The items to be updated.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The response data from the database.</p> Example <p>items = [client.get({\"id\": \"123\"}), client.get({\"id\": \"456\"})] for item in items:     item.name = \"new name\" response = client.update_many(items)</p> Source code in <code>src/pydaadop/api_clients/many_read_write_api_client.py</code> <pre><code>def update_many(self, items: List[T]) -&gt; Dict:\n    \"\"\"\n    Updates multiple items in the database.\n\n    Args:\n        items (List[T]): The items to be updated.\n\n    Returns:\n        Dict: The response data from the database.\n\n    Example:\n        items = [client.get({\"id\": \"123\"}), client.get({\"id\": \"456\"})]\n        for item in items:\n            item.name = \"new name\"\n        response = client.update_many(items)\n    \"\"\"\n    if not items or len(items) == 0:\n        return {}\n    endpoint = self.model_class.__name__.lower() + \"-update-many\"\n    items_dict = [item.model_dump() for item in items]\n    response_data = self._request(\"PUT\", endpoint, json=items_dict)\n    return response_data\n</code></pre>"},{"location":"api/api_clients/many_read_write_api_client/#pydaadop.api_clients.many_read_write_api_client.ManyReadWriteApiClient.update_field_many","title":"update_field_many","text":"<pre><code>update_field_many(items: List[dict], data: dict) -&gt; Dict\n</code></pre> <p>Updates specific fields of multiple items in the database.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[dict]</code> <p>The items to be updated.</p> required <code>data</code> <code>dict</code> <p>The fields to be updated.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The response data from the database.</p> Example <p>items = [{\"id\": \"123\"}, {\"id\": \"456\"}] data = {\"name\": \"new name\"} response = client.update_field_many(items, data)</p> Source code in <code>src/pydaadop/api_clients/many_read_write_api_client.py</code> <pre><code>def update_field_many(self, items: List[dict], data: dict) -&gt; Dict:\n    \"\"\"\n    Updates specific fields of multiple items in the database.\n\n    Args:\n        items (List[dict]): The items to be updated.\n        data (dict): The fields to be updated.\n\n    Returns:\n        Dict: The response data from the database.\n\n    Example:\n        items = [{\"id\": \"123\"}, {\"id\": \"456\"}]\n        data = {\"name\": \"new name\"}\n        response = client.update_field_many(items, data)\n    \"\"\"\n    if not items or len(items) == 0:\n        return {}\n    endpoint = self.model_class.__name__.lower() + \"-update-field-many\"\n    data_dict = {\"data\": data}\n    items_dict = [item for item in items]\n    combined = {**data_dict, **items_dict}\n    response_data = self._request(\"PUT\", endpoint, json=combined)\n    return response_data\n</code></pre>"},{"location":"api/api_clients/many_read_write_api_client/#pydaadop.api_clients.many_read_write_api_client.ManyReadWriteApiClient.delete_many","title":"delete_many","text":"<pre><code>delete_many(items: List[dict]) -&gt; None\n</code></pre> <p>Deletes multiple items from the database.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[dict]</code> <p>The items to be deleted.</p> required Example <p>items = [{\"id\": \"123\"}, {\"id\": \"456\"}] client.delete_many(items)</p> Source code in <code>src/pydaadop/api_clients/many_read_write_api_client.py</code> <pre><code>def delete_many(self, items: List[dict]) -&gt; None:\n    \"\"\"\n    Deletes multiple items from the database.\n\n    Args:\n        items (List[dict]): The items to be deleted.\n\n    Example:\n        items = [{\"id\": \"123\"}, {\"id\": \"456\"}]\n        client.delete_many(items)\n    \"\"\"\n    if not items or len(items) == 0:\n        return\n    items = [item for item in items if item != {}]\n    if not items or len(items) == 0:\n        return\n    endpoint = self.model_class.__name__.lower() + \"-delete-many\"\n    self._request(\"DELETE\", endpoint, json=items)\n</code></pre>"},{"location":"api/api_clients/read_api_client/","title":"read_api_client","text":""},{"location":"api/api_clients/read_api_client/#pydaadop.api_clients.read_api_client.ReadApiClient","title":"ReadApiClient","text":"<pre><code>ReadApiClient(base_url: str, model_class: Type[T], headers: Dict[str, str] = None)\n</code></pre> <p>               Bases: <code>BaseApiClient[T]</code></p> <p>A client for performing read operations on a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the API.</p> required <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the requests.</p> <code>None</code> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def __init__(self, base_url: str, model_class: Type[T], headers: Dict[str, str] = None):\n    self.base_url = base_url\n    self.model_class = model_class\n    self.headers = headers or {}\n</code></pre>"},{"location":"api/api_clients/read_write_api_client/","title":"read_write_api_client","text":""},{"location":"api/api_clients/read_write_api_client/#pydaadop.api_clients.read_write_api_client.ReadWriteApiClient","title":"ReadWriteApiClient","text":"<pre><code>ReadWriteApiClient(base_url: str, model_class: Type[T], headers: Dict[str, str] = None)\n</code></pre> <p>               Bases: <code>ReadApiClient[T]</code></p> <p>A client for performing read and write operations on a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the API.</p> required <code>model_class</code> <code>Type[T]</code> <p>The model class to be used.</p> required <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the requests.</p> <code>None</code> Source code in <code>src/pydaadop/api_clients/base_api_client.py</code> <pre><code>def __init__(self, base_url: str, model_class: Type[T], headers: Dict[str, str] = None):\n    self.base_url = base_url\n    self.model_class = model_class\n    self.headers = headers or {}\n</code></pre>"},{"location":"api/api_clients/read_write_api_client/#pydaadop.api_clients.read_write_api_client.ReadWriteApiClient.insert","title":"insert","text":"<pre><code>insert(item: T) -&gt; T\n</code></pre> <p>Inserts a new item into the database.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to be inserted.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The inserted item with updated fields from the database.</p> Example <p>new_item = MyModel(name=\"example\") inserted_item = client.insert(new_item)</p> Source code in <code>src/pydaadop/api_clients/read_write_api_client.py</code> <pre><code>def insert(self, item: T) -&gt; T:\n    \"\"\"\n    Inserts a new item into the database.\n\n    Args:\n        item (T): The item to be inserted.\n\n    Returns:\n        T: The inserted item with updated fields from the database.\n\n    Example:\n        new_item = MyModel(name=\"example\")\n        inserted_item = client.insert(new_item)\n    \"\"\"\n    endpoint = self.model_class.__name__.lower()\n    item_dict = item.model_dump()\n    response_data = self._request(\"POST\", endpoint, json=item_dict)\n    return self.model_class(**response_data)\n</code></pre>"},{"location":"api/api_clients/read_write_api_client/#pydaadop.api_clients.read_write_api_client.ReadWriteApiClient.update","title":"update","text":"<pre><code>update(item: T) -&gt; T\n</code></pre> <p>Updates an existing item in the database.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to be updated.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The updated item with fields from the database.</p> Example <p>existing_item = client.get({\"id\": \"123\"}) existing_item.name = \"new name\" updated_item = client.update(existing_item)</p> Source code in <code>src/pydaadop/api_clients/read_write_api_client.py</code> <pre><code>def update(self, item: T) -&gt; T:\n    \"\"\"\n    Updates an existing item in the database.\n\n    Args:\n        item (T): The item to be updated.\n\n    Returns:\n        T: The updated item with fields from the database.\n\n    Example:\n        existing_item = client.get({\"id\": \"123\"})\n        existing_item.name = \"new name\"\n        updated_item = client.update(existing_item)\n    \"\"\"\n    endpoint = f\"{self.model_class.__name__.lower()}\"\n    item_dict = item.model_dump()\n    response_data = self._request(\"PUT\", endpoint, json=item_dict)\n    return self.model_class(**response_data)\n</code></pre>"},{"location":"api/api_clients/read_write_api_client/#pydaadop.api_clients.read_write_api_client.ReadWriteApiClient.delete","title":"delete","text":"<pre><code>delete(key_filter_query: Optional[Dict[str, Any]]) -&gt; None\n</code></pre> <p>Deletes an item from the database.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_query</code> <code>Optional[Dict[str, Any]]</code> <p>The query to filter the item to be deleted.</p> required Example <p>client.delete({\"id\": \"123\"})</p> Source code in <code>src/pydaadop/api_clients/read_write_api_client.py</code> <pre><code>def delete(self, key_filter_query: Optional[Dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Deletes an item from the database.\n\n    Args:\n        key_filter_query (Optional[Dict[str, Any]]): The query to filter the item to be deleted.\n\n    Example:\n        client.delete({\"id\": \"123\"})\n    \"\"\"\n    _params = self._parse_query(key_filter_query=key_filter_query)\n    endpoint = f\"{self.model_class.__name__.lower()}\"\n    self._request(\"DELETE\", endpoint, params=_params)\n</code></pre>"},{"location":"api/database/no_sql/mongodb/","title":"mongodb","text":""},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase","title":"BaseMongoDatabase","text":"<pre><code>BaseMongoDatabase(model: Type[T], database_name: str = 'deriven-database')\n</code></pre> <p>Base class for MongoDB database operations.</p> <p>This class provides basic functionality to interact with a MongoDB database using Motor, an asynchronous MongoDB driver for Python.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[T]</code> <p>The model class that represents the MongoDB collection.</p> <code>database_name</code> <code>str</code> <p>The name of the database to connect to.</p> <code>client</code> <code>AsyncIOMotorClient</code> <p>The Motor client instance.</p> <code>db</code> <code>AsyncIOMotorDatabase</code> <p>The Motor database instance.</p> <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The Motor collection instance.</p> Example <pre><code>from myapp.models import MyModel\nfrom myapp.database.no_sql.mongodb import BaseMongoDatabase\n\ndb = BaseMongoDatabase(model=MyModel, database_name=\"my_database\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The model class that represents the MongoDB collection.</p> required <code>database_name</code> <code>str</code> <p>The name of the database to connect to. Defaults to \"deriven-database\".</p> <code>'deriven-database'</code> Source code in <code>src/pydaadop/database/no_sql/mongodb.py</code> <pre><code>def __init__(self, model: Type[T], database_name: str = \"deriven-database\"):\n    \"\"\"\n    Initializes the BaseMongoDatabase instance.\n\n    Args:\n        model (Type[T]): The model class that represents the MongoDB collection.\n        database_name (str): The name of the database to connect to. Defaults to \"deriven-database\".\n    \"\"\"\n    self.model = model\n    uri = env_manager.get_mongo_uri()\n    self.client: AsyncIOMotorClient  = AsyncIOMotorClient(uri)\n    self.db: AsyncIOMotorDatabase = self.client[database_name]\n    self.collection: AsyncIOMotorCollection = self.db[self.model.__name__]\n    self.ensure_indexes()\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client: AsyncIOMotorClient = AsyncIOMotorClient(uri)\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase.db","title":"db  <code>instance-attribute</code>","text":"<pre><code>db: AsyncIOMotorDatabase = client[database_name]\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase.collection","title":"collection  <code>instance-attribute</code>","text":"<pre><code>collection: AsyncIOMotorCollection = db[__name__]\n</code></pre>"},{"location":"api/database/no_sql/mongodb/#pydaadop.database.no_sql.mongodb.BaseMongoDatabase.ensure_indexes","title":"ensure_indexes","text":"<pre><code>ensure_indexes()\n</code></pre> <p>Ensures that the necessary indexes are created for the collection.</p> <p>This method retrieves the index keys from the model and creates a unique index for the collection. If the only key is \"id\", no index is created. If \"id\" is present among other keys, it is replaced with \"_id\".</p> Example <pre><code>db.ensure_indexes()\n</code></pre> Source code in <code>src/pydaadop/database/no_sql/mongodb.py</code> <pre><code>def ensure_indexes(self):\n    \"\"\"\n    Ensures that the necessary indexes are created for the collection.\n\n    This method retrieves the index keys from the model and creates a unique index\n    for the collection. If the only key is \"id\", no index is created. If \"id\" is\n    present among other keys, it is replaced with \"_id\".\n\n    Example:\n        ```python\n        db.ensure_indexes()\n        ```\n    \"\"\"\n    # Get the index based on the model\n    keys = self.model.create_index()\n\n    # if only _id we do not create an index\n    if len(keys) == 1 and \"id\" in keys:\n        return\n    elif \"id\" in keys:\n        keys.remove(\"id\")\n        keys.append(\"_id\")\n\n    # Ensure a unique index\n    self.collection.create_index(\n        keys,\n        unique=True,\n        name=f\"unique_{self.model.__name__}\"\n    )\n</code></pre>"},{"location":"api/definitions/constraints/","title":"constraints","text":"<p>This module defines constraints used throughout the application.</p> <p>These constraints are used to validate string lengths in various parts of the application.</p> <p>Attributes:</p> Name Type Description <code>MIN_STRING_LENGTH</code> <code>int</code> <p>The minimum allowed length for strings.</p> <code>MAX_STRING_LENGTH</code> <code>int</code> <p>The maximum allowed length for strings.</p> Example <pre><code>from myapp.definitions.constraints import MIN_STRING_LENGTH, MAX_STRING_LENGTH\n\ndef validate_string_length(s: str) -&gt; bool:\n    return MIN_STRING_LENGTH &lt;= len(s) &lt;= MAX_STRING_LENGTH\n</code></pre>"},{"location":"api/definitions/constraints/#pydaadop.definitions.constraints.MIN_STRING_LENGTH","title":"MIN_STRING_LENGTH  <code>module-attribute</code>","text":"<pre><code>MIN_STRING_LENGTH = 1\n</code></pre>"},{"location":"api/definitions/constraints/#pydaadop.definitions.constraints.MAX_STRING_LENGTH","title":"MAX_STRING_LENGTH  <code>module-attribute</code>","text":"<pre><code>MAX_STRING_LENGTH = 100\n</code></pre>"},{"location":"api/factories/base_factory/","title":"base_factory","text":""},{"location":"api/factories/base_factory/#pydaadop.factories.base_factory.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseImplementation)\n</code></pre>"},{"location":"api/factories/base_factory/#pydaadop.factories.base_factory.BaseFactory","title":"BaseFactory","text":"<pre><code>BaseFactory(factories: list[S])\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>src/pydaadop/factories/base_factory.py</code> <pre><code>def __init__(self, factories: list[S]):\n    self.factories = factories\n</code></pre>"},{"location":"api/factories/base_factory/#pydaadop.factories.base_factory.BaseFactory.factories","title":"factories  <code>instance-attribute</code>","text":"<pre><code>factories = factories\n</code></pre>"},{"location":"api/factories/base_factory/#pydaadop.factories.base_factory.BaseFactory.get_implementation","title":"get_implementation","text":"<pre><code>get_implementation(value) -&gt; BaseImplementation or None\n</code></pre> Source code in <code>src/pydaadop/factories/base_factory.py</code> <pre><code>def get_implementation(self, value) -&gt; BaseImplementation or None:\n    for factory in self.factories:\n        if factory.is_factory(value):\n            return factory\n    return None\n</code></pre>"},{"location":"api/factories/base_implementation/","title":"base_implementation","text":""},{"location":"api/factories/base_implementation/#pydaadop.factories.base_implementation.BaseImplementation","title":"BaseImplementation","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/factories/base_implementation/#pydaadop.factories.base_implementation.BaseImplementation.is_factory","title":"is_factory  <code>abstractmethod</code>","text":"<pre><code>is_factory(value) -&gt; bool\n</code></pre> Source code in <code>src/pydaadop/factories/base_implementation.py</code> <pre><code>@abstractmethod\ndef is_factory(self, value) -&gt; bool:\n    pass\n</code></pre>"},{"location":"api/models/base/base_mongo_model/","title":"base_mongo_model","text":""},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.PyObjectId","title":"PyObjectId  <code>module-attribute</code>","text":"<pre><code>PyObjectId = str\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel","title":"BaseMongoModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for MongoDB documents using Pydantic.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[PyObjectId]</code> <p>The unique identifier for the document, mapped from MongoDB's _id.</p>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[PyObjectId] = Field(default_factory=lambda: str(ObjectId()), alias='_id')\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.Config","title":"Config","text":"<p>Pydantic configuration for the BaseMongoModel.</p> <p>Attributes:</p> Name Type Description <code>populate_by_name</code> <code>bool</code> <p>Allow aliasing of fields.</p> <code>arbitrary_types_allowed</code> <code>bool</code> <p>Allow arbitrary types like ObjectId.</p> <code>json_encoders</code> <code>dict</code> <p>Custom JSON encoders for specific types.</p>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.Config.populate_by_name","title":"populate_by_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>populate_by_name = True\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.Config.arbitrary_types_allowed","title":"arbitrary_types_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arbitrary_types_allowed = True\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.Config.json_encoders","title":"json_encoders  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>json_encoders = {ObjectId: str}\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.model_dump","title":"model_dump","text":"<pre><code>model_dump(*args: dict, **kwargs: dict) -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the model to a dictionary, with special handling for datetime and ObjectId fields.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>dict</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The serialized model as a dictionary.</p> Source code in <code>src/pydaadop/models/base/base_mongo_model.py</code> <pre><code>def model_dump(self, *args: dict, **kwargs: dict) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize the model to a dictionary, with special handling for datetime and ObjectId fields.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        Dict[str, Any]: The serialized model as a dictionary.\n    \"\"\"\n    # Serialize with conditions: only include 'id' if it is not None\n    data = super().model_dump()\n\n    # Convert datetime fields to string (ISO 8601 format)\n    for key, value in data.items():\n        if isinstance(value, datetime):\n            data[key] = value.isoformat()  # Convert datetime to string in ISO format\n        elif isinstance(value, ObjectId):\n            data[key] = str(value)  # Convert ObjectId to string\n    # extract ignore_id from args\n    ignore_id = kwargs.get('ignore_id', False)\n\n    # If 'id' is None, exclude it from the serialized output\n    if self.id is not None and not ignore_id:\n        data[\"_id\"] = self.id\n    data.pop(\"id\", None)\n\n    return data\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.create_index","title":"create_index  <code>staticmethod</code>","text":"<pre><code>create_index() -&gt; List[str]\n</code></pre> <p>Define the index fields for the model.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of field names to be indexed.</p> Source code in <code>src/pydaadop/models/base/base_mongo_model.py</code> <pre><code>@staticmethod\ndef create_index() -&gt; List[str]:\n    \"\"\"\n    Define the index fields for the model.\n\n    Returns:\n        List[str]: A list of field names to be indexed.\n    \"\"\"\n    return [\"id\"]\n</code></pre>"},{"location":"api/models/base/base_mongo_model/#pydaadop.models.base.base_mongo_model.BaseMongoModel.model_dump_keys","title":"model_dump_keys","text":"<pre><code>model_dump_keys(*args: dict, **kwargs: dict) -&gt; Dict[str, Any]\n</code></pre> <p>Serialize the model and filter only the indexed fields.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>dict</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The serialized model with only the indexed fields.</p> Source code in <code>src/pydaadop/models/base/base_mongo_model.py</code> <pre><code>def model_dump_keys(self, *args: dict, **kwargs: dict) -&gt; Dict[str, Any]:\n    \"\"\"\n    Serialize the model and filter only the indexed fields.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        Dict[str, Any]: The serialized model with only the indexed fields.\n    \"\"\"\n    # Get the index fields from the model's create_index method\n    index_keys = self.create_index()\n\n    if \"id\" in index_keys:\n        index_keys.remove(\"id\")\n        index_keys.append(\"_id\")\n\n    # Serialize the model and filter only the indexed fields\n    serialized_data = self.model_dump(*args, **kwargs)\n\n    # Select only the indexed fields\n    filtered_data = {key: serialized_data[key] for key in index_keys if key in serialized_data}\n\n    return filtered_data\n</code></pre>"},{"location":"api/models/display/display_item_info/","title":"display_item_info","text":""},{"location":"api/models/display/display_item_info/#pydaadop.models.display.display_item_info.DisplayItemInfo","title":"DisplayItemInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing item information for display.</p> <p>Attributes:</p> Name Type Description <code>items_count</code> <code>int</code> <p>Total number of items.</p>"},{"location":"api/models/display/display_item_info/#pydaadop.models.display.display_item_info.DisplayItemInfo.items_count","title":"items_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>items_count: int = Field(default=0, description='Total number of items')\n</code></pre>"},{"location":"api/models/display/display_query_info/","title":"display_query_info","text":""},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterAttributeInfo","title":"DisplayFilterAttributeInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing a filter attribute for display.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Name of the filter attribute.</p> <code>type</code> <code>Optional[str]</code> <p>Data type of the filter attribute.</p> <code>allowed_values</code> <code>Optional[List[str]]</code> <p>List of allowed values for the filter attribute.</p> <code>parent</code> <code>Optional[str]</code> <p>Parent filter attribute.</p>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterAttributeInfo.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Name of the filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterAttributeInfo.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[str] = Field(default=None, description='Data type of the filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterAttributeInfo.allowed_values","title":"allowed_values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_values: Optional[List[str]] = Field(default=None, description='List of allowed values for the filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterAttributeInfo.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[str] = Field(default=None, description='Parent filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplaySortAttributeInfo","title":"DisplaySortAttributeInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing a sort attribute for display.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Name of the sort attribute.</p> <code>parent</code> <code>Optional[str]</code> <p>Parent sort attribute.</p>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplaySortAttributeInfo.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(default=None, description='Name of the filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplaySortAttributeInfo.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[str] = Field(default=None, description='Parent filter attribute')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterInfo","title":"DisplayFilterInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing filter information for display.</p> <p>Attributes:</p> Name Type Description <code>filter_attributes</code> <code>List[DisplayFilterAttributeInfo]</code> <p>List of filter attributes.</p>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayFilterInfo.filter_attributes","title":"filter_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_attributes: List[DisplayFilterAttributeInfo] = Field(default_factory=list, description='List of filter attributes')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplaySortInfo","title":"DisplaySortInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing sort information for display.</p> <p>Attributes:</p> Name Type Description <code>sort_attributes</code> <code>List[DisplaySortAttributeInfo]</code> <p>List of sort attributes.</p>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplaySortInfo.sort_attributes","title":"sort_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_attributes: List[DisplaySortAttributeInfo] = Field(default_factory=list, description='List of sort attributes')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayQueryInfo","title":"DisplayQueryInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing query information for display.</p> <p>Attributes:</p> Name Type Description <code>filter_info</code> <code>Optional[DisplayFilterInfo]</code> <p>Filter information for the items.</p> <code>sort_info</code> <code>Optional[DisplaySortInfo]</code> <p>Sort information for the items.</p>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayQueryInfo.filter_info","title":"filter_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_info: Optional[DisplayFilterInfo] = Field(default=None, description='Filter information for the items')\n</code></pre>"},{"location":"api/models/display/display_query_info/#pydaadop.models.display.display_query_info.DisplayQueryInfo.sort_info","title":"sort_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_info: Optional[DisplaySortInfo] = Field(default=None, description='Sort information for the items')\n</code></pre>"},{"location":"api/queries/base/base_list_filter/","title":"base_list_filter","text":""},{"location":"api/queries/base/base_list_filter/#pydaadop.queries.base.base_list_filter.BaseListFilter","title":"BaseListFilter","text":"<pre><code>BaseListFilter(value: Optional[List[str]], key: str = '_id')\n</code></pre> <p>BaseListFilter class for filtering lists of items by a specific key.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Optional[List[str]]</code> <p>The list of values to filter by.</p> <code>key</code> <code>str</code> <p>The key to filter by (default is \"_id\").</p> Source code in <code>src/pydaadop/queries/base/base_list_filter.py</code> <pre><code>def __init__(self, value: Optional[List[str]], key: str = \"_id\"):\n    self.key = key\n    self.value = value\n</code></pre>"},{"location":"api/queries/base/base_list_filter/#pydaadop.queries.base.base_list_filter.BaseListFilter.key","title":"key  <code>instance-attribute</code>","text":"<pre><code>key = key\n</code></pre>"},{"location":"api/queries/base/base_list_filter/#pydaadop.queries.base.base_list_filter.BaseListFilter.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = value\n</code></pre>"},{"location":"api/queries/base/base_list_filter/#pydaadop.queries.base.base_list_filter.BaseListFilter.to_mongo_filter","title":"to_mongo_filter","text":"<pre><code>to_mongo_filter() -&gt; dict\n</code></pre> <p>Convert the filter to a MongoDB filter.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The MongoDB filter.</p> Source code in <code>src/pydaadop/queries/base/base_list_filter.py</code> <pre><code>def to_mongo_filter(self) -&gt; dict:\n    \"\"\"\n    Convert the filter to a MongoDB filter.\n\n    Returns:\n        dict: The MongoDB filter.\n    \"\"\"\n    return {self.key: {\"$in\": [ObjectId(value) for value in self.value]}}\n</code></pre>"},{"location":"api/queries/base/base_paging/","title":"base_paging","text":""},{"location":"api/queries/base/base_paging/#pydaadop.queries.base.base_paging.BasePaging","title":"BasePaging","text":"<p>               Bases: <code>BaseModel</code></p> <p>BasePaging class for pagination in query results.</p> <p>Attributes:</p> Name Type Description <code>page</code> <code>int</code> <p>The page number to retrieve (must be greater than or equal to 1).</p> <code>page_size</code> <code>int</code> <p>The number of items per page (must be between 1 and 100).</p>"},{"location":"api/queries/base/base_paging/#pydaadop.queries.base.base_paging.BasePaging.page","title":"page  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page: int = Query(default=1, ge=1, description='The page number to retrieve (must be greater than or equal to 1)')\n</code></pre>"},{"location":"api/queries/base/base_paging/#pydaadop.queries.base.base_paging.BasePaging.page_size","title":"page_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_size: int = Query(default=10, ge=1, le=100000, description='The number of items per page (must be between 1 and 100)')\n</code></pre>"},{"location":"api/queries/base/base_paging/#pydaadop.queries.base.base_paging.BasePaging.skip","title":"skip","text":"<pre><code>skip() -&gt; int\n</code></pre> <p>Calculate the number of items to skip based on the current page and page size.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of items to skip.</p> Source code in <code>src/pydaadop/queries/base/base_paging.py</code> <pre><code>def skip(self) -&gt; int:\n    \"\"\"\n    Calculate the number of items to skip based on the current page and page size.\n\n    Returns:\n        int: The number of items to skip.\n    \"\"\"\n    return (self.page - 1) * self.page_size\n</code></pre>"},{"location":"api/queries/base/base_paging/#pydaadop.queries.base.base_paging.BasePaging.limit","title":"limit","text":"<pre><code>limit() -&gt; int\n</code></pre> <p>Get the limit of items per page.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of items per page.</p> Source code in <code>src/pydaadop/queries/base/base_paging.py</code> <pre><code>def limit(self) -&gt; int:\n    \"\"\"\n    Get the limit of items per page.\n\n    Returns:\n        int: The number of items per page.\n    \"\"\"\n    return self.page_size\n</code></pre>"},{"location":"api/queries/base/base_query/","title":"base_query","text":""},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery","title":"BaseQuery","text":"<p>BaseQuery class for creating and managing query models.</p> <p>Attributes:</p> Name Type Description <code>supported_types</code> <code>list</code> <p>List of supported types for queries.</p> <code>supported_selectable_types</code> <code>list</code> <p>List of supported selectable types for queries.</p>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.supported_types","title":"supported_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_types = [str, int, float]\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.supported_selectable_types","title":"supported_selectable_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_selectable_types = [bool]\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery._get_type","title":"_get_type  <code>classmethod</code>","text":"<pre><code>_get_type(annotation: Any) -&gt; Tuple[type | None, bool]\n</code></pre> <p>Get the type of the annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The annotation to get the type of.</p> required <p>Returns:</p> Type Description <code>Tuple[type | None, bool]</code> <p>Tuple[type | None, bool]: The type and whether it is selectable.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef _get_type(cls, annotation: Any) -&gt; Tuple[type | None, bool]:\n    \"\"\"\n    Get the type of the annotation.\n\n    Args:\n        annotation (Any): The annotation to get the type of.\n\n    Returns:\n        Tuple[type | None, bool]: The type and whether it is selectable.\n    \"\"\"\n    if not annotation:\n        return None, False\n\n    origin = get_origin(annotation) or annotation\n    args = get_args(annotation)\n\n    # Check if it's a basic type directly or an Optional wrapping a basic type\n    if origin in cls.supported_types:\n        return origin, False\n    if args and (args[0] in cls.supported_types):\n        return args[0], False\n\n    # Handle Literal types by extracting the type of its values\n    if origin == Literal:\n        literal_type = type(args[0]) if args else None\n        if literal_type in cls.supported_types:\n            return literal_type, True\n        return None, False\n    if issubclass(origin, Enum):\n        return str, True\n\n    # Recursively check nested types if no valid type is found\n    if args and origin is not None:\n        return cls._get_type(args[0])\n\n    return None, False\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery._is_supported_type","title":"_is_supported_type  <code>classmethod</code>","text":"<pre><code>_is_supported_type(field_type: type, is_selectable: bool, name: str, only_selectable: True) -&gt; bool\n</code></pre> <p>Check if the field type is supported.</p> <p>Parameters:</p> Name Type Description Default <code>field_type</code> <code>type</code> <p>The field type to check.</p> required <code>is_selectable</code> <code>bool</code> <p>Whether the field is selectable.</p> required <code>name</code> <code>str</code> <p>The name of the field.</p> required <code>only_selectable</code> <code>bool</code> <p>Whether to only check selectable fields.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the field type is supported, False otherwise.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef _is_supported_type(cls, field_type: type, is_selectable: bool, name: str, only_selectable: True) -&gt; bool:\n    \"\"\"\n    Check if the field type is supported.\n\n    Args:\n        field_type (type): The field type to check.\n        is_selectable (bool): Whether the field is selectable.\n        name (str): The name of the field.\n        only_selectable (bool): Whether to only check selectable fields.\n\n    Returns:\n        bool: True if the field type is supported, False otherwise.\n    \"\"\"\n    if not only_selectable:\n        return True\n\n    if name.endswith(\"_id\") or is_selectable or field_type in cls.supported_selectable_types:\n        return True\n\n    return False\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery._get_allowed_values","title":"_get_allowed_values  <code>classmethod</code>","text":"<pre><code>_get_allowed_values(annotation: Any) -&gt; list | None\n</code></pre> <p>Extract allowed values if the annotation is a Literal.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The annotation to extract allowed values from.</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list | None: The list of allowed values or None.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef _get_allowed_values(cls, annotation: Any) -&gt; list | None:\n    \"\"\"\n    Extract allowed values if the annotation is a Literal.\n\n    Args:\n        annotation (Any): The annotation to extract allowed values from.\n\n    Returns:\n        list | None: The list of allowed values or None.\n    \"\"\"\n    if get_origin(annotation) == Literal:\n        return list(get_args(annotation))\n\n    args = get_args(annotation)\n\n    if args and args[0]:\n        return cls._get_allowed_values(args[0])\n\n    return None\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.get_fields_of_model","title":"get_fields_of_model  <code>classmethod</code>","text":"<pre><code>get_fields_of_model(model: Type[BaseModel], only_selectable=True) -&gt; Dict[str, Any]\n</code></pre> <p>Get the fields of the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The model to get the fields of.</p> required <code>only_selectable</code> <code>bool</code> <p>Whether to only get selectable fields.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The dictionary of fields.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef get_fields_of_model(cls, model: Type[BaseModel], only_selectable=True) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the fields of the model.\n\n    Args:\n        model (Type[BaseModel]): The model to get the fields of.\n        only_selectable (bool): Whether to only get selectable fields.\n\n    Returns:\n        Dict[str, Any]: The dictionary of fields.\n    \"\"\"\n    all_fields: Dict[str, Any] = {}\n    field_overrides = {}\n\n    # Collect fields and their annotations, skipping custom classes\n    model_fields = get_type_hints(model)\n    for name, annotation in model_fields.items():\n        # Only add fields that are basic types\n        field_type, selectable = cls._get_type(annotation)\n        if cls._is_supported_type(field_type, selectable, name, only_selectable):\n            if name in all_fields:\n                all_fields[name].append(annotation)\n            else:\n                all_fields[name] = [annotation]\n\n    # Process the fields to set as optional in the combined model\n    for name, annotations in all_fields.items():\n        base_annotation = annotations[0]\n\n        # Ensure all annotations are identical\n        for annotation in annotations:\n            assert annotation == base_annotation, f\"{name} has different types in the models\"\n\n        # Make the field optional and add to field overrides\n        field_overrides[name] = (Optional[base_annotation], Query(None))\n\n    return field_overrides\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_filter","title":"create_filter  <code>classmethod</code>","text":"<pre><code>create_filter(models: list[Type[BaseModel]], only_selectable=True) -&gt; Type[BaseModel]\n</code></pre> <p>Create a filter model for the given models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[Type[BaseModel]]</code> <p>The list of models to create the filter for.</p> required <code>only_selectable</code> <code>bool</code> <p>Whether to only create selectable fields.</p> <code>True</code> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The created filter model.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_filter(cls, models: list[Type[BaseModel]], only_selectable=True) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a filter model for the given models.\n\n    Args:\n        models (list[Type[BaseModel]]): The list of models to create the filter for.\n        only_selectable (bool): Whether to only create selectable fields.\n\n    Returns:\n        Type[BaseModel]: The created filter model.\n    \"\"\"\n    field_overrides = {}\n    name = \"\"\n    for model in models:\n        name += model.__name__\n        field_overrides.update(cls.get_fields_of_model(model, only_selectable))\n\n    # Create a new model dynamically with the combined optional fields\n    query_model = create_model(f\"{name}FilterModel\", **field_overrides)\n    return query_model\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_key_filter","title":"create_key_filter  <code>classmethod</code>","text":"<pre><code>create_key_filter(models: list[Type[BaseModel]]) -&gt; Type[BaseModel]\n</code></pre> <p>Create a key filter model for the given models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[Type[BaseModel]]</code> <p>The list of models to create the key filter for.</p> required <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The created key filter model.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_key_filter(cls, models: list[Type[BaseModel]]) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a key filter model for the given models.\n\n    Args:\n        models (list[Type[BaseModel]]): The list of models to create the key filter for.\n\n    Returns:\n        Type[BaseModel]: The created key filter model.\n    \"\"\"\n    field_overrides = {}\n    name = \"\"\n    for model in models:\n        name += model.__name__\n        field_names = model.create_index()\n        fields = cls.get_fields_of_model(model, False)\n\n        for key in fields:\n            if key in field_names:\n                field_overrides[key] = fields[key]\n\n    # Create a new model dynamically with the combined optional fields\n    query_model = create_model(f\"{name}KeyFilterModel\", **field_overrides)\n    return query_model\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.split_filter","title":"split_filter  <code>classmethod</code>","text":"<pre><code>split_filter(models: [Type[BaseModel]], filter_data: Dict) -&gt; List[Dict]\n</code></pre> <p>Split the filter data into the different models based on the keys which represent the model fields.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>[Type[BaseModel]]</code> <p>The list of models to split the filter data for.</p> required <code>filter_data</code> <code>Dict</code> <p>The filter data to split.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: The list of split filter data.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef split_filter(cls, models: [Type[BaseModel]], filter_data: Dict) -&gt; List[Dict]:\n    \"\"\"\n    Split the filter data into the different models based on the keys which represent the model fields.\n\n    Args:\n        models ([Type[BaseModel]]): The list of models to split the filter data for.\n        filter_data (Dict): The filter data to split.\n\n    Returns:\n        List[Dict]: The list of split filter data.\n    \"\"\"\n    # split the filter data into the different models based on the keys which represent the model fields\n    split_filter_data = [{} for _ in range(len(models))]\n\n    for key, value in filter_data.items():\n        for i, model in enumerate(models):\n            if key in get_type_hints(model):\n                split_filter_data[i][key] = value\n                break\n\n    return split_filter_data\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.split_sort","title":"split_sort  <code>classmethod</code>","text":"<pre><code>split_sort(models: [Type[BaseModel]], sort_model: BaseSort) -&gt; List[BaseSort | None]\n</code></pre> <p>Split the sort model into the different models based on the sort_by field.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>[Type[BaseModel]]</code> <p>The list of models to split the sort model for.</p> required <code>sort_model</code> <code>BaseSort</code> <p>The sort model to split.</p> required <p>Returns:</p> Type Description <code>List[BaseSort | None]</code> <p>List[BaseSort | None]: The list of split sort models.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef split_sort(cls, models: [Type[BaseModel]], sort_model: BaseSort) -&gt; List[BaseSort | None]:\n    \"\"\"\n    Split the sort model into the different models based on the sort_by field.\n\n    Args:\n        models ([Type[BaseModel]]): The list of models to split the sort model for.\n        sort_model (BaseSort): The sort model to split.\n\n    Returns:\n        List[BaseSort | None]: The list of split sort models.\n    \"\"\"\n    # check if the sort model has a sort_by field\n    if not sort_model.sort_by:\n        return [None for _ in range(len(models))]\n\n    # the sort by field is in one of the models\n    sort_by = sort_model.sort_by\n\n    # find the first model that has the sort_by field\n    for i, model in enumerate(models):\n        if sort_by in get_type_hints(model):\n            return [BaseSort(sort_by=sort_by, sort_order=sort_model.sort_order) if j == i else None for j in range(len(models))]\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.extract_filter","title":"extract_filter  <code>classmethod</code>","text":"<pre><code>extract_filter(filter_model: BaseModel, exclude=True) -&gt; dict\n</code></pre> <p>Extract the filter data from the filter model.</p> <p>Parameters:</p> Name Type Description Default <code>filter_model</code> <code>BaseModel</code> <p>The filter model to extract the data from.</p> required <code>exclude</code> <code>bool</code> <p>Whether to exclude None, unset, and default values.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The extracted filter data.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef extract_filter(cls, filter_model: BaseModel, exclude=True) -&gt; dict:\n    \"\"\"\n    Extract the filter data from the filter model.\n\n    Args:\n        filter_model (BaseModel): The filter model to extract the data from.\n        exclude (bool): Whether to exclude None, unset, and default values.\n\n    Returns:\n        dict: The extracted filter data.\n    \"\"\"\n    filter_data = filter_model.model_dump(exclude_none=exclude, exclude_unset=exclude, exclude_defaults=exclude)\n\n    if \"id\" in filter_data:\n        filter_data[\"_id\"] = filter_data.pop(\"id\")\n\n    return filter_data\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.extract_range","title":"extract_range  <code>classmethod</code>","text":"<pre><code>extract_range(range_model: BaseRange) -&gt; dict\n</code></pre> <p>Extract the range data from the range model.</p> <p>Parameters:</p> Name Type Description Default <code>range_model</code> <code>BaseRange</code> <p>The range model to extract the data from.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The extracted range data.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef extract_range(cls, range_model: BaseRange) -&gt; dict:\n    \"\"\"\n    Extract the range data from the range model.\n\n    Args:\n        range_model (BaseRange): The range model to extract the data from.\n\n    Returns:\n        dict: The extracted range data.\n    \"\"\"\n    if not range_model.range_by or not (range_model.gte_value or range_model.lte_value):\n        return {}\n\n    range_dict = {range_model.range_by: {}}\n    if range_model.gte_value:\n        range_dict[range_model.range_by][\"$gte\"] = int(\n            range_model.gte_value) if range_model.gte_value.isdigit() else range_model.gte_value\n    if range_model.lte_value:\n        range_dict[range_model.range_by][\"$lte\"] = int(\n            range_model.lte_value) if range_model.lte_value.isdigit() else range_model.lte_value\n\n    return range_dict\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_sort","title":"create_sort  <code>classmethod</code>","text":"<pre><code>create_sort(models: list[Type[BaseModel]]) -&gt; Type[BaseSort]\n</code></pre> <p>Create a sort model for the given models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[Type[BaseModel]]</code> <p>The list of models to create the sort model for.</p> required <p>Returns:</p> Type Description <code>Type[BaseSort]</code> <p>Type[BaseSort]: The created sort model.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_sort(cls, models: list[Type[BaseModel]]) -&gt; Type[BaseSort]:\n    \"\"\"\n    Create a sort model for the given models.\n\n    Args:\n        models (list[Type[BaseModel]]): The list of models to create the sort model for.\n\n    Returns:\n        Type[BaseSort]: The created sort model.\n    \"\"\"\n    model_name = \"_\".join([model.__name__ for model in models])\n    filter_model = cls.create_filter(models, only_selectable=False)\n    filterable_fields = cls.extract_filter(filter_model(), exclude=False)\n    # only take the keys\n    filterable_fields_names = [str(key) for key in filterable_fields.keys()]\n\n    if not filterable_fields_names or len(filterable_fields_names) == 0:\n        return BaseSort\n\n    # sort_by_literal = Literal[*filterable_fields_names]\n    sort_by_literal = Literal.__getitem__(tuple(filterable_fields_names))\n\n    # now we create a sort model for the model\n    class CustomSort(BaseSort):\n        # Dynamically define the sort_by field based on filterable_fields\n        sort_by: Optional[sort_by_literal] = Query(\n            default=None,\n            description=\"Field to sort by\"\n        )\n\n    return create_model(\n        f\"{model_name}Sort\",  # Set the name dynamically\n        __base__=CustomSort  # Inherit from BaseRange\n    )\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_range","title":"create_range  <code>classmethod</code>","text":"<pre><code>create_range(models: list[Type[BaseModel]]) -&gt; Type[BaseRange]\n</code></pre> <p>Create a range model for the given models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[Type[BaseModel]]</code> <p>The list of models to create the range model for.</p> required <p>Returns:</p> Type Description <code>Type[BaseRange]</code> <p>Type[BaseRange]: The created range model.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_range(cls, models: list[Type[BaseModel]]) -&gt; Type[BaseRange]:\n    \"\"\"\n    Create a range model for the given models.\n\n    Args:\n        models (list[Type[BaseModel]]): The list of models to create the range model for.\n\n    Returns:\n        Type[BaseRange]: The created range model.\n    \"\"\"\n    model_name = \"_\".join([model.__name__ for model in models])\n    filter_model = cls.create_filter(models, only_selectable=False)\n    filterable_fields = cls.extract_filter(filter_model(), exclude=False)\n    # only take the keys\n    filterable_fields_names = [str(key) for key in filterable_fields.keys()]\n\n    if not filterable_fields_names or len(filterable_fields_names) == 0:\n        return BaseRange\n\n    # sort_by_literal = Literal[*filterable_fields_names]\n    sort_by_literal = Literal.__getitem__(tuple(filterable_fields_names))\n\n    # now we create a sort model for the model\n    class CustomRange(BaseRange):\n        # Dynamically define the sort_by field based on filterable_fields\n        range_by: Optional[sort_by_literal] = Query(\n            default=None,\n            description=\"Field to slect range by\"\n        )\n        __name__ = f\"{model_name}Range\"\n\n    return create_model(\n        f\"{model_name}Range\",  # Set the name dynamically\n        __base__=CustomRange  # Inherit from BaseRange\n    )\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_select","title":"create_select  <code>classmethod</code>","text":"<pre><code>create_select(models: list[Type[BaseModel]]) -&gt; Type[BaseSelect]\n</code></pre> <p>Create a select model for the given models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[Type[BaseModel]]</code> <p>The list of models to create the select model for.</p> required <p>Returns:</p> Type Description <code>Type[BaseSelect]</code> <p>Type[BaseSelect]: The created select model.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_select(cls, models: list[Type[BaseModel]]) -&gt; Type[BaseSelect]:\n    \"\"\"\n    Create a select model for the given models.\n\n    Args:\n        models (list[Type[BaseModel]]): The list of models to create the select model for.\n\n    Returns:\n        Type[BaseSelect]: The created select model.\n    \"\"\"\n    model_name = \"_\".join([model.__name__ for model in models])\n    # get all the fields of the models and create a boolean field for each field\n    selectable_fields = {}\n    for model in models:\n        model_fields = get_type_hints(model)\n        for name, annotation in model_fields.items():\n            field_type, _ = cls._get_type(annotation)\n            selectable_fields[name] = name\n\n    if not selectable_fields:\n        return BaseSelect\n\n    # create the selectable fields (each field is a boolean)\n    selectable_fields_literal = Literal.__getitem__(tuple(selectable_fields.keys()))\n\n    class CustomSelect(BaseSelect):\n        # Dynamically define the select field based on selectable_fields\n        selected_field: Optional[selectable_fields_literal] = Query(\n            default=None,\n            description=\"Field to select\"\n        )\n\n    return create_model(\n        f\"{model_name}Select\",  # Set the name dynamically\n        __base__=CustomSelect  # Inherit from BaseRange\n    )\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.extract_search","title":"extract_search  <code>classmethod</code>","text":"<pre><code>extract_search(model: Type[BaseModel], search_model: BaseSearch) -&gt; Dict\n</code></pre> <p>Extract the search query from the search model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The model to extract the search query for.</p> required <code>search_model</code> <code>BaseSearch</code> <p>The search model to extract the query from.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The extracted search query.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef extract_search(cls, model: Type[BaseModel], search_model: BaseSearch) -&gt; Dict:\n    \"\"\"\n    Extract the search query from the search model.\n\n    Args:\n        model (Type[BaseModel]): The model to extract the search query for.\n        search_model (BaseSearch): The search model to extract the query from.\n\n    Returns:\n        Dict: The extracted search query.\n    \"\"\"\n    if not search_model.search:\n        return {}\n    filter_model = cls.create_filter([model], only_selectable=False)\n    searchable_fields = cls.extract_filter(filter_model(), exclude=False)\n    # only take the keys\n    searchable_field_names = [str(key) for key in searchable_fields.keys()]\n\n    search_query = {\n        \"$or\": [\n            {field: {\"$regex\": search_model.search, \"$options\": \"i\"}} for field in searchable_field_names\n        ]\n    }\n\n    return search_query\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_display_filter_info","title":"create_display_filter_info  <code>classmethod</code>","text":"<pre><code>create_display_filter_info(model: Type[BaseModel]) -&gt; DisplayFilterInfo\n</code></pre> <p>Create display filter info for the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The model to create the display filter info for.</p> required <p>Returns:</p> Name Type Description <code>DisplayFilterInfo</code> <code>DisplayFilterInfo</code> <p>The created display filter info.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_display_filter_info(cls, model: Type[BaseModel]) -&gt; DisplayFilterInfo:\n    \"\"\"\n    Create display filter info for the given model.\n\n    Args:\n        model (Type[BaseModel]): The model to create the display filter info for.\n\n    Returns:\n        DisplayFilterInfo: The created display filter info.\n    \"\"\"\n    filter_model = cls.create_filter([model], only_selectable=True)\n\n    model_fields = get_type_hints(filter_model)\n\n    filter_attributes = []\n\n    for name, annotation in model_fields.items():\n        field_type, _ = cls._get_type(annotation)\n        if not field_type:\n            continue\n\n        allowed_values = cls._get_allowed_values(annotation)\n\n        # Create the filter attribute info\n        filter_attribute = DisplayFilterAttributeInfo(\n            name=name,\n            type=field_type.__name__,\n            allowed_values=allowed_values,\n            parent=model.__name__\n        )\n        filter_attributes.append(filter_attribute)\n\n    return DisplayFilterInfo(filter_attributes=filter_attributes)\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.combine_display_filter_info","title":"combine_display_filter_info  <code>classmethod</code>","text":"<pre><code>combine_display_filter_info(info_filters: list[DisplayFilterInfo]) -&gt; DisplayFilterInfo\n</code></pre> <p>Combine multiple display filter info objects into one.</p> <p>Parameters:</p> Name Type Description Default <code>info_filters</code> <code>list[DisplayFilterInfo]</code> <p>The list of display filter info objects to combine.</p> required <p>Returns:</p> Name Type Description <code>DisplayFilterInfo</code> <code>DisplayFilterInfo</code> <p>The combined display filter info.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef combine_display_filter_info(cls, info_filters: list[DisplayFilterInfo]) -&gt; DisplayFilterInfo:\n    \"\"\"\n    Combine multiple display filter info objects into one.\n\n    Args:\n        info_filters (list[DisplayFilterInfo]): The list of display filter info objects to combine.\n\n    Returns:\n        DisplayFilterInfo: The combined display filter info.\n    \"\"\"\n    combined_filter_info = None\n\n    for info_filter in info_filters:\n        if not combined_filter_info:\n            combined_filter_info = info_filter\n            continue\n        combined_filter_info.filter_attributes.extend(info_filter.filter_attributes)\n\n    return combined_filter_info\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.combine_display_sort_info","title":"combine_display_sort_info  <code>classmethod</code>","text":"<pre><code>combine_display_sort_info(info_sorts: list[DisplaySortInfo]) -&gt; DisplaySortInfo\n</code></pre> <p>Combine multiple display sort info objects into one.</p> <p>Parameters:</p> Name Type Description Default <code>info_sorts</code> <code>list[DisplaySortInfo]</code> <p>The list of display sort info objects to combine.</p> required <p>Returns:</p> Name Type Description <code>DisplaySortInfo</code> <code>DisplaySortInfo</code> <p>The combined display sort info.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef combine_display_sort_info(cls, info_sorts: list[DisplaySortInfo]) -&gt; DisplaySortInfo:\n    \"\"\"\n    Combine multiple display sort info objects into one.\n\n    Args:\n        info_sorts (list[DisplaySortInfo]): The list of display sort info objects to combine.\n\n    Returns:\n        DisplaySortInfo: The combined display sort info.\n    \"\"\"\n    combined_sort_info = None\n\n    for info_sort in info_sorts:\n        if not combined_sort_info:\n            combined_sort_info = info_sort\n            continue\n        combined_sort_info.sort_attributes.extend(info_sort.sort_attributes)\n\n    return combined_sort_info\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.combine_display_query_info","title":"combine_display_query_info  <code>classmethod</code>","text":"<pre><code>combine_display_query_info(info_queries: list[DisplayQueryInfo]) -&gt; DisplayQueryInfo\n</code></pre> <p>Combine multiple display query info objects into one.</p> <p>Parameters:</p> Name Type Description Default <code>info_queries</code> <code>list[DisplayQueryInfo]</code> <p>The list of display query info objects to combine.</p> required <p>Returns:</p> Name Type Description <code>DisplayQueryInfo</code> <code>DisplayQueryInfo</code> <p>The combined display query info.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef combine_display_query_info(cls, info_queries: list[DisplayQueryInfo]) -&gt; DisplayQueryInfo:\n    \"\"\"\n    Combine multiple display query info objects into one.\n\n    Args:\n        info_queries (list[DisplayQueryInfo]): The list of display query info objects to combine.\n\n    Returns:\n        DisplayQueryInfo: The combined display query info.\n    \"\"\"\n    combined_query_info = DisplayQueryInfo(\n        filter_info=cls.combine_display_filter_info([info_query.filter_info for info_query in info_queries]),\n        sort_info=cls.combine_display_sort_info([info_query.sort_info for info_query in info_queries])\n    )\n    return combined_query_info\n</code></pre>"},{"location":"api/queries/base/base_query/#pydaadop.queries.base.base_query.BaseQuery.create_display_sort_info","title":"create_display_sort_info  <code>classmethod</code>","text":"<pre><code>create_display_sort_info(model: Type[BaseModel]) -&gt; DisplaySortInfo\n</code></pre> <p>Create display sort info for the given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The model to create the display sort info for.</p> required <p>Returns:</p> Name Type Description <code>DisplaySortInfo</code> <code>DisplaySortInfo</code> <p>The created display sort info.</p> Source code in <code>src/pydaadop/queries/base/base_query.py</code> <pre><code>@classmethod\ndef create_display_sort_info(cls, model: Type[BaseModel]) -&gt; DisplaySortInfo:\n    \"\"\"\n    Create display sort info for the given model.\n\n    Args:\n        model (Type[BaseModel]): The model to create the display sort info for.\n\n    Returns:\n        DisplaySortInfo: The created display sort info.\n    \"\"\"\n    filter_model = cls.create_filter([model], only_selectable=False)\n    filterable_fields = cls.extract_filter(filter_model(), exclude=False)\n    # only take the keys\n    filterable_fields_names = [DisplaySortAttributeInfo(name=str(key), parent=model.__name__) for key in filterable_fields.keys()]\n\n    return DisplaySortInfo(sort_attributes=filterable_fields_names)\n</code></pre>"},{"location":"api/queries/base/base_range/","title":"base_range","text":""},{"location":"api/queries/base/base_range/#pydaadop.queries.base.base_range.BaseRange","title":"BaseRange","text":"<p>               Bases: <code>BaseModel</code></p> <p>BaseRange class for specifying range queries.</p> <p>Attributes:</p> Name Type Description <code>range_by</code> <code>Optional[str]</code> <p>Field to range by.</p> <code>gte_value</code> <code>Optional[str]</code> <p>Minimum value.</p> <code>lte_value</code> <code>Optional[str]</code> <p>Maximum value.</p>"},{"location":"api/queries/base/base_range/#pydaadop.queries.base.base_range.BaseRange.range_by","title":"range_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>range_by: Optional[str] = Query(default=None, min_length=1, max_length=100, description='Field to range by')\n</code></pre>"},{"location":"api/queries/base/base_range/#pydaadop.queries.base.base_range.BaseRange.gte_value","title":"gte_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gte_value: Optional[str] = Query(default=None, min_length=1, max_length=100, description='Minimum value')\n</code></pre>"},{"location":"api/queries/base/base_range/#pydaadop.queries.base.base_range.BaseRange.lte_value","title":"lte_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lte_value: Optional[str] = Query(default=None, min_length=1, max_length=100, description='Maximum value')\n</code></pre>"},{"location":"api/queries/base/base_search/","title":"base_search","text":""},{"location":"api/queries/base/base_search/#pydaadop.queries.base.base_search.BaseSearch","title":"BaseSearch","text":"<p>               Bases: <code>BaseModel</code></p> <p>BaseSearch class for searching query results.</p> <p>Attributes:</p> Name Type Description <code>search</code> <code>Optional[str]</code> <p>Search string.</p>"},{"location":"api/queries/base/base_search/#pydaadop.queries.base.base_search.BaseSearch.search","title":"search  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>search: Optional[str] = Query(None, description='Search string')\n</code></pre>"},{"location":"api/queries/base/base_select/","title":"base_select","text":""},{"location":"api/queries/base/base_select/#pydaadop.queries.base.base_select.BaseSelect","title":"BaseSelect","text":"<p>               Bases: <code>BaseModel</code></p> <p>BaseSelect class for selecting specific fields in query results.</p> <p>Attributes:</p> Name Type Description <code>selected_field</code> <code>Optional[str]</code> <p>Field to select.</p>"},{"location":"api/queries/base/base_select/#pydaadop.queries.base.base_select.BaseSelect.selected_field","title":"selected_field  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>selected_field: Optional[str] = Query(default=None, min_length=1, max_length=100, description='Select field to return')\n</code></pre>"},{"location":"api/queries/base/base_sort/","title":"base_sort","text":""},{"location":"api/queries/base/base_sort/#pydaadop.queries.base.base_sort.BaseSort","title":"BaseSort","text":"<p>               Bases: <code>BaseModel</code></p> <p>BaseSort class for sorting query results.</p> <p>Attributes:</p> Name Type Description <code>sort_by</code> <code>Optional[str]</code> <p>Field to sort by.</p> <code>sort_order</code> <code>Literal['asc', 'desc']</code> <p>Sort order: 'asc' for ascending, 'desc' for descending.</p>"},{"location":"api/queries/base/base_sort/#pydaadop.queries.base.base_sort.BaseSort.sort_by","title":"sort_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_by: Optional[str] = Query(default=None, min_length=1, max_length=100, description='Field to sort by')\n</code></pre>"},{"location":"api/queries/base/base_sort/#pydaadop.queries.base.base_sort.BaseSort.sort_order","title":"sort_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_order: Literal['asc', 'desc'] = Query(default='asc', description=\"Sort order: 'asc' for ascending, 'desc' for descending\")\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/","title":"base_read_repository","text":"<p>This module provides the BaseReadRepository class, which implements the repository for reading MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseReadRepository</code> <p>A repository class for reading MongoDB models.</p>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository","title":"BaseReadRepository","text":"<pre><code>BaseReadRepository(model: Type[T], collection: AsyncIOMotorCollection = None)\n</code></pre> <p>               Bases: <code>BaseRepository[T]</code></p> <p>A repository class for reading MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>def __init__(self, model: Type[T], collection: AsyncIOMotorCollection = None):\n    \"\"\"\n    Initialize the BaseReadRepository.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        collection (AsyncIOMotorCollection, optional): The MongoDB collection. Defaults to None.\n    \"\"\"\n    super().__init__(model, collection)\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(keys_filter_query: dict) -&gt; bool\n</code></pre> <p>Check if an item exists based on the filter query.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item exists, False otherwise.</p> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>async def exists(self, keys_filter_query: dict) -&gt; bool:\n    \"\"\"\n    Check if an item exists based on the filter query.\n\n    Args:\n        keys_filter_query (dict): The filter query.\n\n    Returns:\n        bool: True if the item exists, False otherwise.\n    \"\"\"\n    return await self.collection.count_documents(keys_filter_query) &gt; 0\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository.get_by_id","title":"get_by_id  <code>async</code>","text":"<pre><code>get_by_id(keys_filter_query: dict) -&gt; Optional[T]\n</code></pre> <p>Get an item based on the filter query.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query.</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: The retrieved item, or None if not found.</p> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>async def get_by_id(self, keys_filter_query: dict) -&gt; Optional[T]:\n    \"\"\"\n    Get an item based on the filter query.\n\n    Args:\n        keys_filter_query (dict): The filter query.\n\n    Returns:\n        Optional[T]: The retrieved item, or None if not found.\n    \"\"\"\n    data = await self.collection.find_one(keys_filter_query)\n    return self.model(**data) if data else None\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository.list","title":"list  <code>async</code>","text":"<pre><code>list(paging_query: BasePaging = BasePaging(), filter_query: Dict = None, sort_query: Optional[BaseSort] = None, search_query: Dict = None) -&gt; List[T]\n</code></pre> <p>List items based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>paging_query</code> <code>BasePaging</code> <p>The paging query. Defaults to BasePaging().</p> <code>BasePaging()</code> <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>List[T]: The list of items.</p> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>async def list(\n        self, paging_query: BasePaging = BasePaging(),\n        filter_query: Dict = None,\n        sort_query: Optional[BaseSort] = None,\n        search_query: Dict = None\n) -&gt; List[T]:\n    \"\"\"\n    List items based on various queries.\n\n    Args:\n        paging_query (BasePaging, optional): The paging query. Defaults to BasePaging().\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n\n    Returns:\n        List[T]: The list of items.\n    \"\"\"\n    if filter_query is None:\n        filter_query = {}\n    filter_query.update(search_query or {})\n\n    cursor = self.collection.find(filter_query).skip(paging_query.skip()).limit(paging_query.limit())\n\n    if sort_query and sort_query.sort_by and sort_query.sort_order:\n        sort_order = 1 if sort_query.sort_order == \"asc\" else -1\n        if sort_query.sort_by:\n            cursor = cursor.sort(sort_query.sort_by, sort_order)\n\n    items = [self.model(**item) async for item in cursor]\n    return items\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository.list_keys","title":"list_keys  <code>async</code>","text":"<pre><code>list_keys(keys: List[str], filter_query: Dict = None, search_query: Dict = None, sort_query: Optional[BaseSort] = None) -&gt; List[Dict]\n</code></pre> <p>List keys of items based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[str]</code> <p>The list of keys to retrieve.</p> required <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: The list of keys.</p> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>async def list_keys(\n        self, keys: List[str],\n        filter_query: Dict = None,\n        search_query: Dict = None,\n        sort_query: Optional[BaseSort] = None,\n) -&gt; List[Dict]:\n    \"\"\"\n    List keys of items based on various queries.\n\n    Args:\n        keys (List[str]): The list of keys to retrieve.\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n\n    Returns:\n        List[Dict]: The list of keys.\n    \"\"\"\n    if filter_query is None:\n        filter_query = {}\n    filter_query.update(search_query or {})\n\n    # Use self.collection to perform the query, projecting only the _id field\n    cursor = self.collection.find(filter_query, {key: 1 for key in keys})\n\n    if sort_query and sort_query.sort_by and sort_query.sort_order:\n        sort_order = 1 if sort_query.sort_order == \"asc\" else -1\n        if sort_query.sort_by:\n            cursor = cursor.sort(sort_query.sort_by, sort_order)\n\n    # Fetch the IDs asynchronously, this time we only request the _id field\n    result_keys = await cursor.to_list(length=None)  # Fetch all matching documents\n\n    # Directly extract the ID from the result\n    return result_keys\n</code></pre>"},{"location":"api/repositories/base/base_read_repository/#pydaadop.repositories.base.base_read_repository.BaseReadRepository.info","title":"info  <code>async</code>","text":"<pre><code>info(filter_query: Dict = None, search_query: Dict = None) -&gt; DisplayItemInfo\n</code></pre> <p>Get item information based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DisplayItemInfo</code> <code>DisplayItemInfo</code> <p>The item information.</p> Source code in <code>src/pydaadop/repositories/base/base_read_repository.py</code> <pre><code>async def info(self, filter_query: Dict = None, search_query: Dict = None) -&gt; DisplayItemInfo:\n    \"\"\"\n    Get item information based on various queries.\n\n    Args:\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n\n    Returns:\n        DisplayItemInfo: The item information.\n    \"\"\"\n    # get the count of the items\n    if filter_query is None:\n        filter_query = {}\n    filter_query.update(search_query or {})\n\n    count = await self.collection.count_documents(filter_query)\n    return DisplayItemInfo(items_count=count)\n</code></pre>"},{"location":"api/repositories/base/base_read_write_repository/","title":"base_read_write_repository","text":"<p>This module provides the BaseReadWriteRepository class, which implements the repository for reading and writing MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseReadWriteRepository</code> <p>A repository class for reading and writing MongoDB models.</p>"},{"location":"api/repositories/base/base_read_write_repository/#pydaadop.repositories.base.base_read_write_repository.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/repositories/base/base_read_write_repository/#pydaadop.repositories.base.base_read_write_repository.BaseReadWriteRepository","title":"BaseReadWriteRepository","text":"<pre><code>BaseReadWriteRepository(model: Type[T], collection: AsyncIOMotorCollection = None)\n</code></pre> <p>               Bases: <code>BaseReadRepository[T]</code></p> <p>A repository class for reading and writing MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/repositories/base/base_read_write_repository.py</code> <pre><code>def __init__(self, model: Type[T], collection: AsyncIOMotorCollection = None):\n    \"\"\"\n    Initialize the BaseReadWriteRepository.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        collection (AsyncIOMotorCollection, optional): The MongoDB collection. Defaults to None.\n    \"\"\"\n    super().__init__(model, collection)\n</code></pre>"},{"location":"api/repositories/base/base_read_write_repository/#pydaadop.repositories.base.base_read_write_repository.BaseReadWriteRepository.create","title":"create  <code>async</code>","text":"<pre><code>create(item: T) -&gt; T\n</code></pre> <p>Create an item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to create.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The created item.</p> Source code in <code>src/pydaadop/repositories/base/base_read_write_repository.py</code> <pre><code>async def create(self, item: T) -&gt; T:\n    \"\"\"\n    Create an item.\n\n    Args:\n        item (T): The item to create.\n\n    Returns:\n        T: The created item.\n    \"\"\"\n    result = await self.collection.insert_one(item.model_dump())\n    item.id = str(result.inserted_id)  # Ensure the model has an 'id' field\n    return item\n</code></pre>"},{"location":"api/repositories/base/base_read_write_repository/#pydaadop.repositories.base.base_read_write_repository.BaseReadWriteRepository.update","title":"update  <code>async</code>","text":"<pre><code>update(keys_filter_query: dict, item_data: T) -&gt; Optional[T]\n</code></pre> <p>Update an item.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The key filter query.</p> required <code>item_data</code> <code>T</code> <p>The item data to update.</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Optional[T]: The updated item, or None if not found.</p> Source code in <code>src/pydaadop/repositories/base/base_read_write_repository.py</code> <pre><code>async def update(self, keys_filter_query: dict, item_data: T) -&gt; Optional[T]:\n    \"\"\"\n    Update an item.\n\n    Args:\n        keys_filter_query (dict): The key filter query.\n        item_data (T): The item data to update.\n\n    Returns:\n        Optional[T]: The updated item, or None if not found.\n    \"\"\"\n    await self.collection.update_one(keys_filter_query, {\"$set\": item_data.model_dump(ignore_id=True)})\n    return await self.get_by_id(keys_filter_query)\n</code></pre>"},{"location":"api/repositories/base/base_read_write_repository/#pydaadop.repositories.base.base_read_write_repository.BaseReadWriteRepository.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(keys_filter_query: dict) -&gt; None\n</code></pre> <p>Delete an item.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The key filter query.</p> required Source code in <code>src/pydaadop/repositories/base/base_read_write_repository.py</code> <pre><code>async def delete(self, keys_filter_query: dict) -&gt; None:\n    \"\"\"\n    Delete an item.\n\n    Args:\n        keys_filter_query (dict): The key filter query.\n    \"\"\"\n    await self.collection.delete_one(keys_filter_query)\n</code></pre>"},{"location":"api/repositories/base/base_repository/","title":"base_repository","text":"<p>This module provides the BaseRepository class, which serves as a base repository for MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseRepository</code> <p>A base repository class for MongoDB models.</p>"},{"location":"api/repositories/base/base_repository/#pydaadop.repositories.base.base_repository.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/repositories/base/base_repository/#pydaadop.repositories.base.base_repository.BaseRepository","title":"BaseRepository","text":"<pre><code>BaseRepository(model: Type[T], collection: AsyncIOMotorCollection = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A base repository class for MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/repositories/base/base_repository.py</code> <pre><code>def __init__(self, model: Type[T], collection: AsyncIOMotorCollection = None):\n    \"\"\"\n    Initialize the BaseRepository.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        collection (AsyncIOMotorCollection, optional): The MongoDB collection. Defaults to None.\n    \"\"\"\n    self.model = model\n    self.collection = collection if collection else BaseMongoDatabase(model).collection\n</code></pre>"},{"location":"api/repositories/base/base_repository/#pydaadop.repositories.base.base_repository.BaseRepository.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"api/repositories/base/base_repository/#pydaadop.repositories.base.base_repository.BaseRepository.collection","title":"collection  <code>instance-attribute</code>","text":"<pre><code>collection = collection if collection else collection\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/","title":"many_read_write_repository","text":"<p>This module provides the ManyReadWriteRepository class, which implements the repository for reading and writing multiple MongoDB models.</p> <p>Classes:</p> Name Description <code>ManyReadWriteRepository</code> <p>A repository class for reading and writing multiple MongoDB models.</p>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.ManyReadWriteRepository","title":"ManyReadWriteRepository","text":"<pre><code>ManyReadWriteRepository(model: Type[T], collection: AsyncIOMotorCollection = None)\n</code></pre> <p>               Bases: <code>BaseReadWriteRepository[T]</code></p> <p>A repository class for reading and writing multiple MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>collection</code> <code>AsyncIOMotorCollection</code> <p>The MongoDB collection. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/repositories/many/many_read_write_repository.py</code> <pre><code>def __init__(self, model: Type[T], collection: AsyncIOMotorCollection = None):\n    \"\"\"\n    Initialize the ManyReadWriteRepository.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        collection (AsyncIOMotorCollection, optional): The MongoDB collection. Defaults to None.\n    \"\"\"\n    super().__init__(model, collection)\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.ManyReadWriteRepository.create_many","title":"create_many  <code>async</code>","text":"<pre><code>create_many(items: List[T]) -&gt; InsertManyResult\n</code></pre> <p>Create multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The list of items to create.</p> required <p>Returns:</p> Name Type Description <code>InsertManyResult</code> <code>InsertManyResult</code> <p>The result of the insert operation.</p> Source code in <code>src/pydaadop/repositories/many/many_read_write_repository.py</code> <pre><code>async def create_many(self, items: List[T]) -&gt; InsertManyResult:\n    \"\"\"\n    Create multiple items.\n\n    Args:\n        items (List[T]): The list of items to create.\n\n    Returns:\n        InsertManyResult: The result of the insert operation.\n    \"\"\"\n    serialized_items = [item.model_dump(by_alias=True) for item in items]\n    return await self.collection.insert_many(serialized_items, ordered=False)\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.ManyReadWriteRepository.update_many","title":"update_many  <code>async</code>","text":"<pre><code>update_many(items: List[T]) -&gt; BulkWriteResult\n</code></pre> <p>Update multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The list of items to update.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/repositories/many/many_read_write_repository.py</code> <pre><code>async def update_many(self, items: List[T]) -&gt; BulkWriteResult:\n    \"\"\"\n    Update multiple items.\n\n    Args:\n        items (List[T]): The list of items to update.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    bulk_write_operations = [UpdateOne(item.model_dump_keys(), {\"$set\": item.model_dump()}) for item in items]\n    return await self.collection.bulk_write(bulk_write_operations)\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.ManyReadWriteRepository.update_field_many","title":"update_field_many  <code>async</code>","text":"<pre><code>update_field_many(keys_filter_query: List[dict], data: dict) -&gt; BulkWriteResult\n</code></pre> <p>Update a field of multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>List[dict]</code> <p>The list of key filter queries.</p> required <code>data</code> <code>dict</code> <p>The data to update.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/repositories/many/many_read_write_repository.py</code> <pre><code>async def update_field_many(self, keys_filter_query: List[dict], data: dict) -&gt; BulkWriteResult:\n    \"\"\"\n    Update a field of multiple items.\n\n    Args:\n        keys_filter_query (List[dict]): The list of key filter queries.\n        data (dict): The data to update.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    bulk_write_operations = [UpdateOne(key_filter, {\"$set\": data}) for key_filter in keys_filter_query]\n    return await self.collection.bulk_write(bulk_write_operations)\n</code></pre>"},{"location":"api/repositories/many/many_read_write_repository/#pydaadop.repositories.many.many_read_write_repository.ManyReadWriteRepository.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(keys_filter_query: List[dict]) -&gt; DeleteResult\n</code></pre> <p>Delete multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>List[dict]</code> <p>The list of key filter queries.</p> required <p>Returns:</p> Name Type Description <code>DeleteResult</code> <code>DeleteResult</code> <p>The result of the delete operation.</p> Source code in <code>src/pydaadop/repositories/many/many_read_write_repository.py</code> <pre><code>async def delete_many(self, keys_filter_query: List[dict]) -&gt; DeleteResult:\n    \"\"\"\n    Delete multiple items.\n\n    Args:\n        keys_filter_query (List[dict]): The list of key filter queries.\n\n    Returns:\n        DeleteResult: The result of the delete operation.\n    \"\"\"\n    return await self.collection.delete_many({\"$or\": keys_filter_query})\n</code></pre>"},{"location":"api/routes/base/base_read_route/","title":"base_read_route","text":"<p>This module provides the BaseReadRouter class, which sets up routes for reading MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseReadRouter</code> <p>A router class for reading MongoDB models.</p>"},{"location":"api/routes/base/base_read_route/#pydaadop.routes.base.base_read_route.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/routes/base/base_read_route/#pydaadop.routes.base.base_read_route.BaseReadRouter","title":"BaseReadRouter","text":"<pre><code>BaseReadRouter(model: Type[T], service: ReadServiceInterface = None)\n</code></pre> <p>               Bases: <code>BaseRouter[T]</code></p> <p>A router class for reading MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>service</code> <code>ReadServiceInterface</code> <p>The service for reading operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>service</code> <code>ReadServiceInterface</code> <p>The service for reading operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/routes/base/base_read_route.py</code> <pre><code>def __init__(self, model: Type[T], service: ReadServiceInterface = None):\n    \"\"\"\n    Initialize the BaseReadRouter.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        service (ReadServiceInterface, optional): The service for reading operations. Defaults to None.\n    \"\"\"\n    self.service = service if service else BaseReadService(model)\n    super().__init__(model)\n</code></pre>"},{"location":"api/routes/base/base_read_route/#pydaadop.routes.base.base_read_route.BaseReadRouter.service","title":"service  <code>instance-attribute</code>","text":"<pre><code>service = service if service else BaseReadService(model)\n</code></pre>"},{"location":"api/routes/base/base_read_route/#pydaadop.routes.base.base_read_route.BaseReadRouter.create_openapi_schema","title":"create_openapi_schema","text":"<pre><code>create_openapi_schema(schema: dict) -&gt; dict\n</code></pre> <p>Create the OpenAPI schema for the routes.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>dict</code> <p>The OpenAPI schema.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The updated OpenAPI schema.</p> Source code in <code>src/pydaadop/routes/base/base_read_route.py</code> <pre><code>@override\ndef create_openapi_schema(self, schema: dict) -&gt; dict:\n    \"\"\"\n    Create the OpenAPI schema for the routes.\n\n    Args:\n        schema (dict): The OpenAPI schema.\n\n    Returns:\n        dict: The updated OpenAPI schema.\n    \"\"\"\n    models = [self.service.create_filter(), self.service.create_key_filter(), self.service.create_range(), self.service.create_sort(),\n              self.service.create_select()]\n\n    # Ensure the components section exists\n    if schema.get(\"components\") is None:\n        schema[\"components\"] = {}\n    if schema[\"components\"].get(\"schemas\") is None:\n        schema[\"components\"][\"schemas\"] = {}\n\n    for model in models:\n        dynamic_model_schema = model.model_json_schema()\n        dynamic_model_schema[\"title\"] = model.__name__\n\n        # Dynamically add the model schema to OpenAPI\n        schema[\"components\"][\"schemas\"][model.__name__] = dynamic_model_schema\n\n    return schema\n</code></pre>"},{"location":"api/routes/base/base_read_route/#pydaadop.routes.base.base_read_route.BaseReadRouter.setup_routes","title":"setup_routes","text":"<pre><code>setup_routes()\n</code></pre> <p>Set up the routes for reading operations.</p> Source code in <code>src/pydaadop/routes/base/base_read_route.py</code> <pre><code>@override\ndef setup_routes(self):\n    \"\"\"\n    Set up the routes for reading operations.\n    \"\"\"\n    super().setup_routes()\n\n    model = self.model  # Store the model locally for static use\n    filter_model = self.service.create_filter()\n    key_filter_model = self.service.create_key_filter()\n    range_model = self.service.create_range()\n    sort_model = self.service.create_sort()\n    select_model = self.service.create_select()\n\n    @self.router.get(f\"{self.prefix}/display-info/query/\", response_model=DisplayQueryInfo)\n    async def get_display_query_info():\n        \"\"\"\n        Get display query information.\n\n        Returns:\n            DisplayQueryInfo: The display query information.\n        \"\"\"\n        display_info = await self.service.query_info(model=model)\n        return display_info\n\n    @self.router.get(f\"{self.prefix}/display-info/item/\", response_model=DisplayItemInfo)\n    async def get_display_item_info(\n            filter_query: filter_model = Depends(),\n            range_query: range_model = Depends(),\n            search_query: BaseSearch = Depends()):\n        \"\"\"\n        Get display item information.\n\n        Args:\n            filter_query (filter_model, optional): The filter query. Defaults to Depends().\n            range_query (range_model, optional): The range query. Defaults to Depends().\n            search_query (BaseSearch, optional): The search query. Defaults to Depends().\n\n        Returns:\n            DisplayItemInfo: The display item information.\n        \"\"\"\n        range_dict = BaseQuery.extract_range(range_query)\n        filter_dict = BaseQuery.extract_filter(filter_model=filter_query)\n        search_dict = BaseQuery.extract_search(model=model, search_model=search_query)\n        display_info = await self.service.item_info(filter_query=filter_dict, range_query=range_dict, search_query=search_dict)\n        return display_info\n\n    @self.router.get(f\"{self.prefix}/\", response_model=List[model])\n    async def get_all(\n            sort_query: sort_model = Depends(),\n            range_query: range_model = Depends(),\n            paging_query: BasePaging = Depends(),\n            filter_query: filter_model = Depends(),\n            search_query: BaseSearch = Depends()):\n        \"\"\"\n        Get all items.\n\n        Args:\n            sort_query (sort_model, optional): The sort query. Defaults to Depends().\n            range_query (range_model, optional): The range query. Defaults to Depends().\n            paging_query (BasePaging, optional): The paging query. Defaults to Depends().\n            filter_query (filter_model, optional): The filter query. Defaults to Depends().\n            search_query (BaseSearch, optional): The search query. Defaults to Depends().\n\n        Returns:\n            List[model]: The list of items.\n        \"\"\"\n        range_dict = BaseQuery.extract_range(range_query)\n        filter_dict = BaseQuery.extract_filter(filter_query)\n        search_dict = BaseQuery.extract_search(model, search_query)\n        items = await self.service.list(filter_query=filter_dict, sort_query=sort_query, paging_query=paging_query,\n                                        range_query=range_dict, search_query=search_dict)\n        return items\n\n    @self.router.get(f\"{self.prefix}/select/\", response_model=List[dict])\n    async def get_all_select(\n            select_query: select_model = Depends(),\n            range_query: range_model = Depends(),\n            sort_query: sort_model = Depends(),\n            filter_query: filter_model = Depends(),\n            search_query: BaseSearch = Depends()):\n        \"\"\"\n        Get all items with selected fields.\n\n        Args:\n            select_query (select_model, optional): The select query. Defaults to Depends().\n            range_query (range_model, optional): The range query. Defaults to Depends().\n            sort_query (sort_model, optional): The sort query. Defaults to Depends().\n            filter_query (filter_model, optional): The filter query. Defaults to Depends().\n            search_query (BaseSearch, optional): The search query. Defaults to Depends().\n\n        Returns:\n            List[dict]: The list of items with selected fields.\n        \"\"\"\n        keys = [select_query.selected_field]\n        range_dict = BaseQuery.extract_range(range_query)\n        filter_dict = BaseQuery.extract_filter(filter_query)\n        search_dict = BaseQuery.extract_search(model, search_query)\n        items = await self.service.list_keys(keys=keys, filter_query=filter_dict, sort_query=sort_query,\n                                             range_query=range_dict, search_query=search_dict)\n\n        # Adjust the _id to be string instead of ObjectId\n        for item in items:\n            item[\"_id\"] = str(item[\"_id\"])\n\n\n        return items\n\n    @self.router.get(f\"{self.prefix}/exists/\", response_model=bool)\n    async def item_exists(key_filter_query: key_filter_model = Depends()):\n        \"\"\"\n        Check if an item exists.\n\n        Args:\n            key_filter_query (key_filter_model, optional): The key filter query. Defaults to Depends().\n\n        Returns:\n            bool: True if the item exists, False otherwise.\n        \"\"\"\n        key_filter_dict = BaseQuery.extract_filter(key_filter_query)\n        return await self.service.exists(key_filter_dict)\n\n\n    @self.router.get(f\"{self.prefix}/item/\", response_model=model)\n    async def get_item(key_filter_query: key_filter_model = Depends()):\n        \"\"\"\n        Get an item.\n\n        Args:\n            key_filter_query (key_filter_model, optional): The key filter query. Defaults to Depends().\n\n        Returns:\n            model: The item.\n\n        Raises:\n            HTTPException: If the item is not found.\n        \"\"\"\n        key_filter_dict = BaseQuery.extract_filter(key_filter_query)\n        item = await self.service.get(key_filter_dict)\n        if not item:\n            raise HTTPException(status_code=404, detail=\"Item not found\")\n        return item\n</code></pre>"},{"location":"api/routes/base/base_read_write_route/","title":"base_read_write_route","text":"<p>This module provides the BaseReadWriteRouter class, which sets up routes for reading and writing MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseReadWriteRouter</code> <p>A router class for reading and writing MongoDB models.</p>"},{"location":"api/routes/base/base_read_write_route/#pydaadop.routes.base.base_read_write_route.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/routes/base/base_read_write_route/#pydaadop.routes.base.base_read_write_route.BaseReadWriteRouter","title":"BaseReadWriteRouter","text":"<pre><code>BaseReadWriteRouter(model: Type[T], service: ReadWriteServiceInterface = None)\n</code></pre> <p>               Bases: <code>BaseReadRouter[T]</code></p> <p>A router class for reading and writing MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>service</code> <code>ReadWriteServiceInterface</code> <p>The service for reading and writing operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>service</code> <code>ReadWriteServiceInterface</code> <p>The service for reading and writing operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/routes/base/base_read_write_route.py</code> <pre><code>def __init__(self, model: Type[T], service: ReadWriteServiceInterface = None):\n    \"\"\"\n    Initialize the BaseReadWriteRouter.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        service (ReadWriteServiceInterface, optional): The service for reading and writing operations. Defaults to None.\n    \"\"\"\n    self.service = service if service else BaseReadWriteService(model)\n    super().__init__(model, self.service)\n</code></pre>"},{"location":"api/routes/base/base_read_write_route/#pydaadop.routes.base.base_read_write_route.BaseReadWriteRouter.service","title":"service  <code>instance-attribute</code>","text":"<pre><code>service = service if service else BaseReadWriteService(model)\n</code></pre>"},{"location":"api/routes/base/base_read_write_route/#pydaadop.routes.base.base_read_write_route.BaseReadWriteRouter.setup_routes","title":"setup_routes","text":"<pre><code>setup_routes()\n</code></pre> <p>Set up the routes for reading and writing MongoDB models.</p> Source code in <code>src/pydaadop/routes/base/base_read_write_route.py</code> <pre><code>@override\ndef setup_routes(self):\n    \"\"\"\n    Set up the routes for reading and writing MongoDB models.\n    \"\"\"\n    key_filter_model = self.service.create_key_filter()\n    super().setup_routes()\n    model = self.model  # Store the model locally for static use\n\n    @self.router.post(f\"{self.prefix}/\")\n    async def create_item(item: model):\n        \"\"\"\n        Create an item.\n\n        Args:\n            item (model): The item to create.\n\n        Returns:\n            model: The created item.\n        \"\"\"\n        created_item = await self.service.create(item)\n        return created_item\n\n    @self.router.put(f\"{self.prefix}/\", response_model=model)\n    async def update_item(item: model):\n        \"\"\"\n        Update an item.\n\n        Args:\n            item (model): The item to update.\n\n        Returns:\n            model: The updated item.\n\n        Raises:\n            HTTPException: If the item is not found.\n        \"\"\"\n        updated_item = await self.service.update(item)\n        if not updated_item:\n            raise HTTPException(status_code=404, detail=\"Item not found\")\n        return updated_item\n\n    @self.router.delete(f\"{self.prefix}/\")\n    async def delete_item(key_filter_query: key_filter_model = Depends()):\n        \"\"\"\n        Delete an item.\n\n        Args:\n            key_filter_query (key_filter_model): The key filter query.\n\n        Returns:\n            dict: A success message.\n        \"\"\"\n        key_filter_dict = BaseQuery.extract_filter(key_filter_query)\n        await self.service.delete(key_filter_dict)\n        return {\"detail\": \"Item deleted successfully\"}\n</code></pre>"},{"location":"api/routes/base/base_route/","title":"base_route","text":"<p>This module provides the BaseRouter class, which serves as a base class for setting up routes for MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseRouter</code> <p>A base router class for setting up routes for MongoDB models.</p>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter","title":"BaseRouter","text":"<pre><code>BaseRouter(model: Type[T])\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A base router class for setting up routes for MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>tags</code> <code>List[str]</code> <p>The tags for the router.</p> <code>router</code> <code>APIRouter</code> <p>The FastAPI router.</p> <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> <code>prefix</code> <code>str</code> <p>The prefix for the routes.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required Source code in <code>src/pydaadop/routes/base/base_route.py</code> <pre><code>def __init__(self, model: Type[T]):\n    \"\"\"\n    Initialize the BaseRouter.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n    \"\"\"\n    self.tags = [model.__name__]\n    self.router = APIRouter(tags=self.tags)\n    self.model = model\n    self.prefix = f\"/{model.__name__.lower()}\"  # Store the prefix\n    self.setup_routes()\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = [__name__]\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.router","title":"router  <code>instance-attribute</code>","text":"<pre><code>router = APIRouter(tags=tags)\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix = f'/{lower()}'\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.create_openapi_schema","title":"create_openapi_schema  <code>abstractmethod</code>","text":"<pre><code>create_openapi_schema(schema: dict)\n</code></pre> <p>Create the OpenAPI schema for the routes.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>dict</code> <p>The OpenAPI schema.</p> required Source code in <code>src/pydaadop/routes/base/base_route.py</code> <pre><code>@abstractmethod\ndef create_openapi_schema(self, schema: dict):\n    \"\"\"\n    Create the OpenAPI schema for the routes.\n\n    Args:\n        schema (dict): The OpenAPI schema.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/routes/base/base_route/#pydaadop.routes.base.base_route.BaseRouter.setup_routes","title":"setup_routes  <code>abstractmethod</code>","text":"<pre><code>setup_routes()\n</code></pre> <p>Set up the routes for the MongoDB model.</p> Source code in <code>src/pydaadop/routes/base/base_route.py</code> <pre><code>@abstractmethod\ndef setup_routes(self):\n    \"\"\"\n    Set up the routes for the MongoDB model.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/routes/many/many_read_write_route/","title":"many_read_write_route","text":"<p>This module provides the ManyReadWriteRouter class, which sets up routes for reading and writing multiple MongoDB models.</p> <p>Classes:</p> Name Description <code>ManyReadWriteRouter</code> <p>A router class for reading and writing multiple MongoDB models.</p>"},{"location":"api/routes/many/many_read_write_route/#pydaadop.routes.many.many_read_write_route.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/routes/many/many_read_write_route/#pydaadop.routes.many.many_read_write_route.ManyReadWriteRouter","title":"ManyReadWriteRouter","text":"<pre><code>ManyReadWriteRouter(model: Type[T], service: ManyReadWriteServiceInterface = None)\n</code></pre> <p>               Bases: <code>BaseReadWriteRouter[T]</code></p> <p>A router class for reading and writing multiple MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the router.</p> <code>service</code> <code>ManyReadWriteServiceInterface</code> <p>The service for reading and writing operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[T]</code> <p>The MongoDB model type.</p> required <code>service</code> <code>ManyReadWriteServiceInterface</code> <p>The service for reading and writing operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/routes/many/many_read_write_route.py</code> <pre><code>def __init__(self, model: Type[T], service: ManyReadWriteServiceInterface = None):\n    \"\"\"\n    Initialize the ManyReadWriteRouter.\n\n    Args:\n        model (Type[T]): The MongoDB model type.\n        service (ManyReadWriteServiceInterface, optional): The service for reading and writing operations. Defaults to None.\n    \"\"\"\n    self.name = \"many\"\n    self.service = service if service else ManyReadWriteService(model)\n    super().__init__(model, self.service)\n</code></pre>"},{"location":"api/routes/many/many_read_write_route/#pydaadop.routes.many.many_read_write_route.ManyReadWriteRouter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = 'many'\n</code></pre>"},{"location":"api/routes/many/many_read_write_route/#pydaadop.routes.many.many_read_write_route.ManyReadWriteRouter.service","title":"service  <code>instance-attribute</code>","text":"<pre><code>service = service if service else ManyReadWriteService(model)\n</code></pre>"},{"location":"api/routes/many/many_read_write_route/#pydaadop.routes.many.many_read_write_route.ManyReadWriteRouter.setup_routes","title":"setup_routes","text":"<pre><code>setup_routes()\n</code></pre> <p>Set up the routes for reading and writing multiple MongoDB models.</p> Source code in <code>src/pydaadop/routes/many/many_read_write_route.py</code> <pre><code>@override\ndef setup_routes(self):\n    \"\"\"\n    Set up the routes for reading and writing multiple MongoDB models.\n    \"\"\"\n    super().setup_routes()\n    key_filter_model = self.service.create_key_filter()\n    model = self.model  # Store the model locally for static use\n\n    @self.router.post(f\"{self.prefix}-insert-many\")\n    async def create_many(items: List[model]) -&gt; dict:\n        \"\"\"\n        Create multiple items.\n\n        Args:\n            items (List[model]): The list of items to create.\n\n        Returns:\n            dict: The IDs of the created items.\n        \"\"\"\n        created_item = await self.service.create_many(items)\n        return {\"ids\": created_item.inserted_ids}\n\n    @self.router.put(f\"{self.prefix}-update-many\")\n    async def update_many(items: List[model]) -&gt; dict:\n        \"\"\"\n        Update multiple items.\n\n        Args:\n            items (List[model]): The list of items to update.\n\n        Returns:\n            dict: The count of updated items.\n\n        Raises:\n            HTTPException: If no items are updated.\n        \"\"\"\n        updated_item = await self.service.update_many(items)\n        if not updated_item:\n            raise HTTPException(status_code=404, detail=\"Item not found\")\n        return {\"ids\": updated_item.modified_count}\n\n    @self.router.put(f\"{self.prefix}-update-field-many\")\n    async def update_field_many(key_filter_queries: List[key_filter_model], data: dict):\n        \"\"\"\n        Update a field of multiple items.\n\n        Args:\n            key_filter_queries (List[key_filter_model]): The list of key filter queries.\n            data (dict): The data to update.\n\n        Returns:\n            dict: A success message.\n        \"\"\"\n        key_filter_dicts = [BaseQuery.extract_filter(query) for query in key_filter_queries]\n        await self.service.update_field_many(key_filter_dicts, data)\n        return {\"detail\": \"Item updated successfully\"}\n\n    @self.router.delete(f\"{self.prefix}-delete-many/\")\n    async def delete_many(key_filter_queries: List[key_filter_model]):\n        \"\"\"\n        Delete multiple items based on a list of dynamically defined query filters.\n\n        Args:\n            key_filter_queries (List[key_filter_model]): The list of key filter queries.\n\n        Returns:\n            dict: A success message.\n        \"\"\"\n        # Extract filters from each key_filter_model instance\n        key_filters = [BaseQuery.extract_filter(query) for query in key_filter_queries]\n\n        # Pass the extracted filters to the service\n        await self.service.delete_many(key_filters)\n        return {\"detail\": \"Items deleted successfully\"}\n</code></pre>"},{"location":"api/services/base/base_read_service/","title":"base_read_service","text":"<p>This module provides the BaseReadService class, which implements the ReadServiceInterface for reading operations on MongoDB models.</p> <p>Classes:</p> Name Description <code>BaseReadService</code> <p>A base service class for reading operations on MongoDB models.</p>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.R","title":"R  <code>module-attribute</code>","text":"<pre><code>R = TypeVar('R', bound=BaseReadRepository[BaseMongoModel])\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService","title":"BaseReadService","text":"<pre><code>BaseReadService(model: Type[S], repository: R = None)\n</code></pre> <p>               Bases: <code>ReadServiceInterface[S]</code>, <code>ABC</code></p> <p>A base service class for reading operations on MongoDB models.</p> <p>Attributes:</p> Name Type Description <code>repository</code> <code>BaseReadRepository</code> <p>The repository for reading operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The MongoDB model type.</p> required <code>repository</code> <code>R</code> <p>The repository for reading operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>def __init__(self, model: Type[S], repository: R = None):\n    \"\"\"\n    Initialize the BaseReadService.\n\n    Args:\n        model (Type[S]): The MongoDB model type.\n        repository (R, optional): The repository for reading operations. Defaults to None.\n    \"\"\"\n    self.repository = repository if repository else BaseReadRepository(model)\n    super().__init__(model)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.repository","title":"repository  <code>instance-attribute</code>","text":"<pre><code>repository = repository if repository else BaseReadRepository(model)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.create_filter","title":"create_filter","text":"<pre><code>create_filter() -&gt; Type[BaseModel]\n</code></pre> <p>Create a filter model for querying.</p> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The filter model.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\ndef create_filter(self) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a filter model for querying.\n\n    Returns:\n        Type[BaseModel]: The filter model.\n    \"\"\"\n    return BaseQuery.create_filter(models=[self.model], only_selectable=True)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.create_key_filter","title":"create_key_filter","text":"<pre><code>create_key_filter() -&gt; Type[BaseModel]\n</code></pre> <p>Create a key filter model for querying.</p> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The key filter model.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\ndef create_key_filter(self) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a key filter model for querying.\n\n    Returns:\n        Type[BaseModel]: The key filter model.\n    \"\"\"\n    return BaseQuery.create_key_filter(models=[self.model])\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.create_sort","title":"create_sort","text":"<pre><code>create_sort() -&gt; Type[BaseSort]\n</code></pre> <p>Create a sort model for querying.</p> <p>Returns:</p> Type Description <code>Type[BaseSort]</code> <p>Type[BaseSort]: The sort model.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\ndef create_sort(self) -&gt; Type[BaseSort]:\n    \"\"\"\n    Create a sort model for querying.\n\n    Returns:\n        Type[BaseSort]: The sort model.\n    \"\"\"\n    return BaseQuery.create_sort(models=[self.model])\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.create_range","title":"create_range","text":"<pre><code>create_range() -&gt; Type[BaseRange]\n</code></pre> <p>Create a range model for querying.</p> <p>Returns:</p> Type Description <code>Type[BaseRange]</code> <p>Type[BaseRange]: The range model.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\ndef create_range(self) -&gt; Type[BaseRange]:\n    \"\"\"\n    Create a range model for querying.\n\n    Returns:\n        Type[BaseRange]: The range model.\n    \"\"\"\n    return BaseQuery.create_range(models=[self.model])\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.create_select","title":"create_select","text":"<pre><code>create_select() -&gt; Type[BaseSelect]\n</code></pre> <p>Create a select model for querying.</p> <p>Returns:</p> Type Description <code>Type[BaseSelect]</code> <p>Type[BaseSelect]: The select model.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\ndef create_select(self) -&gt; Type[BaseSelect]:\n    \"\"\"\n    Create a select model for querying.\n\n    Returns:\n        Type[BaseSelect]: The select model.\n    \"\"\"\n    return BaseQuery.create_select(models=[self.model])\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(keys_filter_query: dict) -&gt; bool\n</code></pre> <p>Check if an item exists based on the filter query.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item exists, False otherwise.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def exists(self, keys_filter_query: dict) -&gt; bool:\n    \"\"\"\n    Check if an item exists based on the filter query.\n\n    Args:\n        keys_filter_query (dict): The filter query.\n\n    Returns:\n        bool: True if the item exists, False otherwise.\n    \"\"\"\n    return await self.repository.exists(keys_filter_query)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.get","title":"get  <code>async</code>","text":"<pre><code>get(keys_filter_query: dict) -&gt; S\n</code></pre> <p>Get an item based on the filter query.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The retrieved item.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the item is not found.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def get(self, keys_filter_query: dict) -&gt; S:\n    \"\"\"\n    Get an item based on the filter query.\n\n    Args:\n        keys_filter_query (dict): The filter query.\n\n    Returns:\n        S: The retrieved item.\n\n    Raises:\n        HTTPException: If the item is not found.\n    \"\"\"\n    item = await self.repository.get_by_id(keys_filter_query)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found.\")\n    return item\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.list","title":"list  <code>async</code>","text":"<pre><code>list(paging_query: BasePaging = BasePaging(), filter_query: Dict = None, sort_query: Optional[BaseSort] = None, search_query: Dict = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; List[S]\n</code></pre> <p>List items based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>paging_query</code> <code>BasePaging</code> <p>The paging query. Defaults to BasePaging().</p> <code>BasePaging()</code> <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>The list filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[S]</code> <p>List[S]: The list of items.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def list(self,\n               paging_query: BasePaging = BasePaging(),\n               filter_query: Dict = None,\n               sort_query: Optional[BaseSort] = None,\n               search_query: Dict = None,\n               range_query: Dict = None,\n               list_filter: BaseListFilter = None) -&gt; List[S]:\n    \"\"\"\n    List items based on various queries.\n\n    Args:\n        paging_query (BasePaging, optional): The paging query. Defaults to BasePaging().\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): The list filter. Defaults to None.\n\n    Returns:\n        List[S]: The list of items.\n    \"\"\"\n    filter_query = self._update_filter_query(filter_query, list_filter)\n    if range_query:\n        filter_query.update(range_query)\n    return await self.repository.list(paging_query, filter_query, sort_query, search_query)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.list_keys","title":"list_keys  <code>async</code>","text":"<pre><code>list_keys(keys: List[str], filter_query: Dict = None, search_query: Dict = None, sort_query: Optional[BaseSort] = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; List[Dict]\n</code></pre> <p>List keys of items based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[str]</code> <p>The list of keys to retrieve.</p> required <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>The list filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: The list of keys.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def list_keys(self,\n                    keys: List[str],\n                    filter_query: Dict = None,\n                    search_query: Dict = None,\n                    sort_query: Optional[BaseSort] = None,\n                    range_query: Dict = None,\n                    list_filter: BaseListFilter = None) -&gt; List[Dict]:\n    \"\"\"\n    List keys of items based on various queries.\n\n    Args:\n        keys (List[str]): The list of keys to retrieve.\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): The list filter. Defaults to None.\n\n    Returns:\n        List[Dict]: The list of keys.\n    \"\"\"\n    filter_query = self._update_filter_query(filter_query, list_filter)\n    if range_query:\n        filter_query.update(range_query)\n    return await self.repository.list_keys(keys=keys, filter_query=filter_query, search_query=search_query, sort_query=sort_query)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.item_info","title":"item_info  <code>async</code>","text":"<pre><code>item_info(filter_query: Dict = None, search_query: Dict = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; DisplayItemInfo\n</code></pre> <p>Get item information based on various queries.</p> <p>Parameters:</p> Name Type Description Default <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>The list filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DisplayItemInfo</code> <code>DisplayItemInfo</code> <p>The item information.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def item_info(self,\n                    filter_query: Dict = None,\n                    search_query: Dict = None,\n                    range_query: Dict = None,\n                    list_filter: BaseListFilter = None) -&gt; DisplayItemInfo:\n    \"\"\"\n    Get item information based on various queries.\n\n    Args:\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): The list filter. Defaults to None.\n\n    Returns:\n        DisplayItemInfo: The item information.\n    \"\"\"\n    updated_filter_query = self._update_filter_query(filter_query, list_filter)\n    if range_query:\n        updated_filter_query.update(range_query)\n    return await self.repository.info(updated_filter_query, search_query)\n</code></pre>"},{"location":"api/services/base/base_read_service/#pydaadop.services.base.base_read_service.BaseReadService.query_info","title":"query_info  <code>async</code>","text":"<pre><code>query_info(model: Type[S]) -&gt; DisplayQueryInfo\n</code></pre> <p>Get query information for the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The MongoDB model type.</p> required <p>Returns:</p> Name Type Description <code>DisplayQueryInfo</code> <code>DisplayQueryInfo</code> <p>The query information.</p> Source code in <code>src/pydaadop/services/base/base_read_service.py</code> <pre><code>@override\nasync def query_info(self, model: Type[S]) -&gt; DisplayQueryInfo:\n    \"\"\"\n    Get query information for the model.\n\n    Args:\n        model (Type[S]): The MongoDB model type.\n\n    Returns:\n        DisplayQueryInfo: The query information.\n    \"\"\"\n    return DisplayQueryInfo(\n        filter_info=BaseQuery.create_display_filter_info(model),\n        sort_info=BaseQuery.create_display_sort_info(model)\n    )\n</code></pre>"},{"location":"api/services/base/base_read_write_service/","title":"base_read_write_service","text":"<p>This module provides the BaseReadWriteService class, which implements the ReadWriteServiceInterface and provides methods for creating, updating, and deleting items in a MongoDB collection.</p>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.R","title":"R  <code>module-attribute</code>","text":"<pre><code>R = TypeVar('R', bound=BaseReadWriteRepository[BaseMongoModel])\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.BaseReadWriteService","title":"BaseReadWriteService","text":"<pre><code>BaseReadWriteService(model: Type[S], repository: R = None)\n</code></pre> <p>               Bases: <code>ReadWriteServiceInterface[S]</code>, <code>BaseReadService[S]</code>, <code>ABC</code></p> <p>Service class for handling read and write operations on a MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[S]</code> <p>The model class.</p> <code>repository</code> <code>R</code> <p>The repository instance for database operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The model class.</p> required <code>repository</code> <code>R</code> <p>The repository instance for database operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/services/base/base_read_write_service.py</code> <pre><code>def __init__(self, model: Type[S], repository: R = None):\n    \"\"\"\n    Initialize the BaseReadWriteService.\n\n    Args:\n        model (Type[S]): The model class.\n        repository (R, optional): The repository instance for database operations. Defaults to None.\n    \"\"\"\n    self.repository = repository if repository else BaseReadWriteRepository(model)\n    super().__init__(model, self.repository)\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.BaseReadWriteService.repository","title":"repository  <code>instance-attribute</code>","text":"<pre><code>repository = repository if repository else BaseReadWriteRepository(model)\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.BaseReadWriteService.create","title":"create  <code>async</code>","text":"<pre><code>create(item: S) -&gt; S\n</code></pre> <p>Create a new item, ensuring it does not already exist based on unique fields.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>S</code> <p>The item to be created.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The created item.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the item already exists.</p> Source code in <code>src/pydaadop/services/base/base_read_write_service.py</code> <pre><code>@override\nasync def create(self, item: S) -&gt; S:\n    \"\"\"\n    Create a new item, ensuring it does not already exist based on unique fields.\n\n    Args:\n        item (S): The item to be created.\n\n    Returns:\n        S: The created item.\n\n    Raises:\n        HTTPException: If the item already exists.\n    \"\"\"\n    existing_item = await self.repository.exists(item.model_dump_keys())\n    if existing_item:\n        raise HTTPException(status_code=400, detail=\"Item already exists.\")\n    return await self.repository.create(item)\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.BaseReadWriteService.update","title":"update  <code>async</code>","text":"<pre><code>update(item: S) -&gt; S\n</code></pre> <p>Update an item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>S</code> <p>The item data to be updated.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The updated item.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the item does not exist.</p> Source code in <code>src/pydaadop/services/base/base_read_write_service.py</code> <pre><code>@override\nasync def update(self, item: S) -&gt; S:\n    \"\"\"\n    Update an item by its ID.\n\n    Args:\n        item (S): The item data to be updated.\n\n    Returns:\n        S: The updated item.\n\n    Raises:\n        HTTPException: If the item does not exist.\n    \"\"\"\n    exists = await self.repository.exists(item.model_dump_keys())\n    if not exists: # create the item\n        return await self.create(item)\n    return await self.repository.update(item.model_dump_keys(), item)\n</code></pre>"},{"location":"api/services/base/base_read_write_service/#pydaadop.services.base.base_read_write_service.BaseReadWriteService.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(keys_filter_query: dict) -&gt; None\n</code></pre> <p>Delete an item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query to identify the item.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the item is not found.</p> Source code in <code>src/pydaadop/services/base/base_read_write_service.py</code> <pre><code>@override\nasync def delete(self, keys_filter_query: dict) -&gt; None:\n    \"\"\"\n    Delete an item by its ID.\n\n    Args:\n        keys_filter_query (dict): The filter query to identify the item.\n\n    Returns:\n        None\n\n    Raises:\n        HTTPException: If the item is not found.\n    \"\"\"\n    existing_item = await self.repository.get_by_id(keys_filter_query)\n    if not existing_item:\n        raise HTTPException(status_code=404, detail=\"Item not found.\")\n    await self.repository.delete(keys_filter_query)\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/","title":"many_read_write_service_interface","text":"<p>This module provides the ManyReadWriteServiceInterface class, which defines the interface for reading and writing multiple MongoDB models.</p> <p>Classes:</p> Name Description <code>ManyReadWriteServiceInterface</code> <p>An interface for reading and writing multiple MongoDB models.</p>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.ManyReadWriteServiceInterface","title":"ManyReadWriteServiceInterface  <code>abstractmethod</code>","text":"<pre><code>ManyReadWriteServiceInterface(model: Type[S])\n</code></pre> <p>               Bases: <code>ReadWriteServiceInterface[S]</code></p> <p>An interface for reading and writing multiple MongoDB models.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>def __init__(self, model: Type[S]):\n    \"\"\"\n    Initialize the ServiceInterface.\n\n    Args:\n        model (Type[S]): The model class.\n    \"\"\"\n    self.model = model\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.ManyReadWriteServiceInterface.create_many","title":"create_many  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_many(item: [S]) -&gt; InsertManyResult\n</code></pre> <p>Create multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>List[S]</code> <p>The list of items to create.</p> required <p>Returns:</p> Name Type Description <code>InsertManyResult</code> <code>InsertManyResult</code> <p>The result of the insert operation.</p> Source code in <code>src/pydaadop/services/interface/many_read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def create_many(self, item: [S]) -&gt; InsertManyResult:\n    \"\"\"\n    Create multiple items.\n\n    Args:\n        item (List[S]): The list of items to create.\n\n    Returns:\n        InsertManyResult: The result of the insert operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.ManyReadWriteServiceInterface.update_many","title":"update_many  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_many(items: [S]) -&gt; BulkWriteResult\n</code></pre> <p>Update multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[S]</code> <p>The list of items to update.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/services/interface/many_read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def update_many(self, items: [S]) -&gt; BulkWriteResult:\n    \"\"\"\n    Update multiple items.\n\n    Args:\n        items (List[S]): The list of items to update.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.ManyReadWriteServiceInterface.update_field_many","title":"update_field_many  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_field_many(key_filter_queries: List[dict], data: dict) -&gt; BulkWriteResult\n</code></pre> <p>Update a field of multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_queries</code> <code>List[dict]</code> <p>The list of key filter queries.</p> required <code>data</code> <code>dict</code> <p>The data to update.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/services/interface/many_read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def update_field_many(self, key_filter_queries: List[dict], data: dict) -&gt; BulkWriteResult:\n    \"\"\"\n    Update a field of multiple items.\n\n    Args:\n        key_filter_queries (List[dict]): The list of key filter queries.\n        data (dict): The data to update.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/many_read_write_service_interface/#pydaadop.services.interface.many_read_write_service_interface.ManyReadWriteServiceInterface.delete_many","title":"delete_many  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_many(key_filter_queries: [dict]) -&gt; None\n</code></pre> <p>Delete multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_queries</code> <code>List[dict]</code> <p>The list of key filter queries.</p> required Source code in <code>src/pydaadop/services/interface/many_read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def delete_many(self, key_filter_queries: [dict]) -&gt; None:\n    \"\"\"\n    Delete multiple items.\n\n    Args:\n        key_filter_queries (List[dict]): The list of key filter queries.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/","title":"read_service_interface","text":"<p>This module provides the ReadServiceInterface class, which defines the interface for service classes that handle read operations on a model.</p>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseModel)\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface","title":"ReadServiceInterface  <code>abstractmethod</code>","text":"<pre><code>ReadServiceInterface(model: Type[S])\n</code></pre> <p>               Bases: <code>ServiceInterface[S]</code></p> <p>Interface for service classes that handle read operations on a model.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>def __init__(self, model: Type[S]):\n    \"\"\"\n    Initialize the ServiceInterface.\n\n    Args:\n        model (Type[S]): The model class.\n    \"\"\"\n    self.model = model\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.exists","title":"exists  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>exists(keys_filter_query: dict) -&gt; bool\n</code></pre> <p>Check if an item exists by its unique ID.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query to identify the item.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item exists, False otherwise.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def exists(self, keys_filter_query: dict) -&gt; bool:\n    \"\"\"\n    Check if an item exists by its unique ID.\n\n    Args:\n        keys_filter_query (dict): The filter query to identify the item.\n\n    Returns:\n        bool: True if the item exists, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.get","title":"get  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get(keys_filter_query: dict) -&gt; S\n</code></pre> <p>Retrieve an item by its unique ID.</p> <p>Parameters:</p> Name Type Description Default <code>keys_filter_query</code> <code>dict</code> <p>The filter query to identify the item.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The retrieved item.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def get(self, keys_filter_query: dict) -&gt; S:\n    \"\"\"\n    Retrieve an item by its unique ID.\n\n    Args:\n        keys_filter_query (dict): The filter query to identify the item.\n\n    Returns:\n        S: The retrieved item.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.list","title":"list  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list(paging_query: BasePaging = BasePaging(), filter_query: Dict = None, sort_query: Optional[BaseSort] = None, search_query: Dict = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; List[S]\n</code></pre> <p>List items with optional paging, filtering, sorting, and search queries.</p> <p>Parameters:</p> Name Type Description Default <code>paging_query</code> <code>BasePaging</code> <p>The paging query. Defaults to BasePaging().</p> <code>BasePaging()</code> <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>Additional filters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[S]</code> <p>List[S]: The list of items.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def list(self,\n               paging_query: BasePaging = BasePaging(),\n               filter_query: Dict = None,\n               sort_query: Optional[BaseSort] = None,\n               search_query: Dict = None,\n               range_query: Dict = None,\n               list_filter: BaseListFilter = None) -&gt; List[S]:\n    \"\"\"\n    List items with optional paging, filtering, sorting, and search queries.\n\n    Args:\n        paging_query (BasePaging, optional): The paging query. Defaults to BasePaging().\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): Additional filters. Defaults to None.\n\n    Returns:\n        List[S]: The list of items.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.list_keys","title":"list_keys  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list_keys(keys: List[str], filter_query: Dict = None, search_query: Dict = None, sort_query: Optional[BaseSort] = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; List[Dict]\n</code></pre> <p>List items with optional filtering, search, and keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[str]</code> <p>The list of keys to retrieve.</p> required <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>sort_query</code> <code>Optional[BaseSort]</code> <p>The sort query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>Additional filters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List[Dict]: The list of items.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def list_keys(self,\n                keys: List[str],\n                filter_query: Dict = None,\n                search_query: Dict = None,\n                sort_query: Optional[BaseSort] = None,\n                range_query: Dict = None,\n                list_filter: BaseListFilter = None) -&gt; List[Dict]:\n    \"\"\"\n    List items with optional filtering, search, and keys.\n\n    Args:\n        keys (List[str]): The list of keys to retrieve.\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        sort_query (Optional[BaseSort], optional): The sort query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): Additional filters. Defaults to None.\n\n    Returns:\n        List[Dict]: The list of items.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.item_info","title":"item_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>item_info(filter_query: Dict = None, search_query: Dict = None, range_query: Dict = None, list_filter: BaseListFilter = None) -&gt; DisplayItemInfo\n</code></pre> <p>Retrieve information about items with optional filtering and search.</p> <p>Parameters:</p> Name Type Description Default <code>filter_query</code> <code>Dict</code> <p>The filter query. Defaults to None.</p> <code>None</code> <code>search_query</code> <code>Dict</code> <p>The search query. Defaults to None.</p> <code>None</code> <code>range_query</code> <code>Dict</code> <p>The range query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>Additional filters. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DisplayItemInfo</code> <code>DisplayItemInfo</code> <p>The information about the items.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def item_info(self,\n                    filter_query: Dict = None,\n                    search_query: Dict = None,\n                    range_query: Dict = None,\n                    list_filter: BaseListFilter = None) -&gt; DisplayItemInfo:\n    \"\"\"\n    Retrieve information about items with optional filtering and search.\n\n    Args:\n        filter_query (Dict, optional): The filter query. Defaults to None.\n        search_query (Dict, optional): The search query. Defaults to None.\n        range_query (Dict, optional): The range query. Defaults to None.\n        list_filter (BaseListFilter, optional): Additional filters. Defaults to None.\n\n    Returns:\n        DisplayItemInfo: The information about the items.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_service_interface/#pydaadop.services.interface.read_service_interface.ReadServiceInterface.query_info","title":"query_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>query_info(model: Type[S]) -&gt; DisplayQueryInfo\n</code></pre> <p>Generate display query info for the provided model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The model class.</p> required <p>Returns:</p> Name Type Description <code>DisplayQueryInfo</code> <code>DisplayQueryInfo</code> <p>The display query info.</p> Source code in <code>src/pydaadop/services/interface/read_service_interface.py</code> <pre><code>@abstractmethod\nasync def query_info(self, model: Type[S]) -&gt; DisplayQueryInfo:\n    \"\"\"\n    Generate display query info for the provided model.\n\n    Args:\n        model (Type[S]): The model class.\n\n    Returns:\n        DisplayQueryInfo: The display query info.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_write_service_interface/","title":"read_write_service_interface","text":"<p>This module provides the ReadWriteServiceInterface class, which defines the interface for service classes that handle read and write operations on a model.</p>"},{"location":"api/services/interface/read_write_service_interface/#pydaadop.services.interface.read_write_service_interface.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseModel)\n</code></pre>"},{"location":"api/services/interface/read_write_service_interface/#pydaadop.services.interface.read_write_service_interface.ReadWriteServiceInterface","title":"ReadWriteServiceInterface  <code>abstractmethod</code>","text":"<pre><code>ReadWriteServiceInterface(model: Type[S])\n</code></pre> <p>               Bases: <code>ReadServiceInterface[S]</code></p> <p>Interface for service classes that handle read and write operations on a model.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>def __init__(self, model: Type[S]):\n    \"\"\"\n    Initialize the ServiceInterface.\n\n    Args:\n        model (Type[S]): The model class.\n    \"\"\"\n    self.model = model\n</code></pre>"},{"location":"api/services/interface/read_write_service_interface/#pydaadop.services.interface.read_write_service_interface.ReadWriteServiceInterface.create","title":"create  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create(item: S) -&gt; S\n</code></pre> <p>Create a new item, ensuring it does not already exist based on unique fields.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>S</code> <p>The item to be created.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The created item.</p> Source code in <code>src/pydaadop/services/interface/read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def create(self, item: S) -&gt; S:\n    \"\"\"\n    Create a new item, ensuring it does not already exist based on unique fields.\n\n    Args:\n        item (S): The item to be created.\n\n    Returns:\n        S: The created item.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_write_service_interface/#pydaadop.services.interface.read_write_service_interface.ReadWriteServiceInterface.update","title":"update  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update(item_data: S) -&gt; S\n</code></pre> <p>Update an item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>item_data</code> <code>S</code> <p>The item data to be updated.</p> required <p>Returns:</p> Name Type Description <code>S</code> <code>S</code> <p>The updated item.</p> Source code in <code>src/pydaadop/services/interface/read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def update(self, item_data: S) -&gt; S:\n    \"\"\"\n    Update an item by its ID.\n\n    Args:\n        item_data (S): The item data to be updated.\n\n    Returns:\n        S: The updated item.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/read_write_service_interface/#pydaadop.services.interface.read_write_service_interface.ReadWriteServiceInterface.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(item_id: str) -&gt; None\n</code></pre> <p>Delete an item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> <p>The ID of the item to be deleted.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/pydaadop/services/interface/read_write_service_interface.py</code> <pre><code>@abstractmethod\nasync def delete(self, item_id: str) -&gt; None:\n    \"\"\"\n    Delete an item by its ID.\n\n    Args:\n        item_id (str): The ID of the item to be deleted.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/service_interface/","title":"service_interface","text":"<p>This module provides the ServiceInterface class, which defines the interface for service classes that handle various operations on a model.</p>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseModel)\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface","title":"ServiceInterface","text":"<pre><code>ServiceInterface(model: Type[S])\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[S]</code></p> <p>Interface for service classes that handle various operations on a model.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[S]</code> <p>The model class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The model class.</p> required Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>def __init__(self, model: Type[S]):\n    \"\"\"\n    Initialize the ServiceInterface.\n\n    Args:\n        model (Type[S]): The model class.\n    \"\"\"\n    self.model = model\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface._update_filter_query","title":"_update_filter_query  <code>classmethod</code>","text":"<pre><code>_update_filter_query(filter_query: Dict = None, list_filter: BaseListFilter = None) -&gt; Dict\n</code></pre> <p>Update the filter query with additional filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_query</code> <code>Dict</code> <p>The original filter query. Defaults to None.</p> <code>None</code> <code>list_filter</code> <code>BaseListFilter</code> <p>Additional filters to be applied. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The updated filter query.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@classmethod\ndef _update_filter_query(cls, filter_query: Dict = None, list_filter: BaseListFilter = None) -&gt; Dict:\n    \"\"\"\n    Update the filter query with additional filters.\n\n    Args:\n        filter_query (Dict, optional): The original filter query. Defaults to None.\n        list_filter (BaseListFilter, optional): Additional filters to be applied. Defaults to None.\n\n    Returns:\n        Dict: The updated filter query.\n    \"\"\"\n    if not filter_query and not list_filter:\n        return {}\n    if not filter_query:\n        filter_query = {}\n    if not list_filter:\n        return filter_query\n\n    # create a copy of the filter query because we don't want to modify the original\n    filter_query_copy = filter_query.copy()\n\n    filter_query_copy.update(list_filter.to_mongo_filter())\n\n    return filter_query_copy\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.create_filter","title":"create_filter  <code>abstractmethod</code>","text":"<pre><code>create_filter() -&gt; Type[BaseModel]\n</code></pre> <p>Create a filter model.</p> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The filter model class.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@abstractmethod\ndef create_filter(self) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a filter model.\n\n    Returns:\n        Type[BaseModel]: The filter model class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.create_key_filter","title":"create_key_filter  <code>abstractmethod</code>","text":"<pre><code>create_key_filter() -&gt; Type[BaseModel]\n</code></pre> <p>Create a key filter model.</p> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Type[BaseModel]: The key filter model class.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@abstractmethod\ndef create_key_filter(self) -&gt; Type[BaseModel]:\n    \"\"\"\n    Create a key filter model.\n\n    Returns:\n        Type[BaseModel]: The key filter model class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.create_sort","title":"create_sort  <code>abstractmethod</code>","text":"<pre><code>create_sort() -&gt; Type[BaseSort]\n</code></pre> <p>Create a sort model.</p> <p>Returns:</p> Type Description <code>Type[BaseSort]</code> <p>Type[BaseSort]: The sort model class.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@abstractmethod\ndef create_sort(self) -&gt; Type[BaseSort]:\n    \"\"\"\n    Create a sort model.\n\n    Returns:\n        Type[BaseSort]: The sort model class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.create_range","title":"create_range  <code>abstractmethod</code>","text":"<pre><code>create_range() -&gt; Type[BaseRange]\n</code></pre> <p>Create a range model.</p> <p>Returns:</p> Type Description <code>Type[BaseRange]</code> <p>Type[BaseRange]: The range model class.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@abstractmethod\ndef create_range(self) -&gt; Type[BaseRange]:\n    \"\"\"\n    Create a range model.\n\n    Returns:\n        Type[BaseRange]: The range model class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/interface/service_interface/#pydaadop.services.interface.service_interface.ServiceInterface.create_select","title":"create_select  <code>abstractmethod</code>","text":"<pre><code>create_select() -&gt; Type[BaseSelect]\n</code></pre> <p>Create a select model.</p> <p>Returns:</p> Type Description <code>Type[BaseSelect]</code> <p>Type[BaseSelect]: The select model class.</p> Source code in <code>src/pydaadop/services/interface/service_interface.py</code> <pre><code>@abstractmethod\ndef create_select(self) -&gt; Type[BaseSelect]:\n    \"\"\"\n    Create a select model.\n\n    Returns:\n        Type[BaseSelect]: The select model class.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/services/many/many_read_write_service/","title":"many_read_write_service","text":"<p>This module provides the ManyReadWriteService class, which implements the ManyReadWriteServiceInterface and provides methods for creating, updating, and deleting multiple items in a MongoDB collection.</p>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.S","title":"S  <code>module-attribute</code>","text":"<pre><code>S = TypeVar('S', bound=BaseMongoModel)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.R","title":"R  <code>module-attribute</code>","text":"<pre><code>R = TypeVar('R', bound=ManyReadWriteRepository[BaseMongoModel])\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService","title":"ManyReadWriteService","text":"<pre><code>ManyReadWriteService(model: Type[S], repository: R = None)\n</code></pre> <p>               Bases: <code>ManyReadWriteServiceInterface[S]</code>, <code>BaseReadWriteService[S]</code>, <code>ABC</code></p> <p>Service class for handling multiple read and write operations on a MongoDB collection.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[S]</code> <p>The model class.</p> <code>repository</code> <code>R</code> <p>The repository instance for database operations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[S]</code> <p>The model class.</p> required <code>repository</code> <code>R</code> <p>The repository instance for database operations. Defaults to None.</p> <code>None</code> Source code in <code>src/pydaadop/services/many/many_read_write_service.py</code> <pre><code>def __init__(self, model: Type[S], repository: R = None):\n    \"\"\"\n    Initialize the ManyReadWriteService.\n\n    Args:\n        model (Type[S]): The model class.\n        repository (R, optional): The repository instance for database operations. Defaults to None.\n    \"\"\"\n    self.repository = repository if repository else ManyReadWriteRepository(model)\n    super().__init__(model, self.repository)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService.repository","title":"repository  <code>instance-attribute</code>","text":"<pre><code>repository = repository if repository else ManyReadWriteRepository(model)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService.create_many","title":"create_many  <code>async</code>","text":"<pre><code>create_many(items: List[S]) -&gt; InsertManyResult\n</code></pre> <p>Create multiple items in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[S]</code> <p>List of items to be created.</p> required <p>Returns:</p> Name Type Description <code>InsertManyResult</code> <code>InsertManyResult</code> <p>The result of the insert operation.</p> Source code in <code>src/pydaadop/services/many/many_read_write_service.py</code> <pre><code>@override\nasync def create_many(self, items: List[S]) -&gt; InsertManyResult:\n    \"\"\"\n    Create multiple items in the collection.\n\n    Args:\n        items (List[S]): List of items to be created.\n\n    Returns:\n        InsertManyResult: The result of the insert operation.\n    \"\"\"\n    return await self.repository.create_many(items)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService.update_many","title":"update_many  <code>async</code>","text":"<pre><code>update_many(items: List[S]) -&gt; BulkWriteResult\n</code></pre> <p>Update multiple items in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[S]</code> <p>List of items to be updated.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/services/many/many_read_write_service.py</code> <pre><code>@override\nasync def update_many(self, items: List[S]) -&gt; BulkWriteResult:\n    \"\"\"\n    Update multiple items in the collection.\n\n    Args:\n        items (List[S]): List of items to be updated.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    return await self.repository.update_many(items)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService.update_field_many","title":"update_field_many  <code>async</code>","text":"<pre><code>update_field_many(key_filter_queries: List[dict], data: dict) -&gt; BulkWriteResult\n</code></pre> <p>Update specific fields of multiple items in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_queries</code> <code>List[dict]</code> <p>List of filter queries to identify items.</p> required <code>data</code> <code>dict</code> <p>Data to be updated.</p> required <p>Returns:</p> Name Type Description <code>BulkWriteResult</code> <code>BulkWriteResult</code> <p>The result of the update operation.</p> Source code in <code>src/pydaadop/services/many/many_read_write_service.py</code> <pre><code>@override\nasync def update_field_many(self, key_filter_queries: List[dict], data: dict) -&gt; BulkWriteResult:\n    \"\"\"\n    Update specific fields of multiple items in the collection.\n\n    Args:\n        key_filter_queries (List[dict]): List of filter queries to identify items.\n        data (dict): Data to be updated.\n\n    Returns:\n        BulkWriteResult: The result of the update operation.\n    \"\"\"\n    return await self.repository.update_field_many(key_filter_queries, data)\n</code></pre>"},{"location":"api/services/many/many_read_write_service/#pydaadop.services.many.many_read_write_service.ManyReadWriteService.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(key_filter_queries: List[dict]) -&gt; DeleteResult\n</code></pre> <p>Delete multiple items from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>key_filter_queries</code> <code>List[dict]</code> <p>List of filter queries to identify items.</p> required <p>Returns:</p> Name Type Description <code>DeleteResult</code> <code>DeleteResult</code> <p>The result of the delete operation.</p> Source code in <code>src/pydaadop/services/many/many_read_write_service.py</code> <pre><code>@override\nasync def delete_many(self, key_filter_queries: List[dict]) -&gt; DeleteResult:\n    \"\"\"\n    Delete multiple items from the collection.\n\n    Args:\n        key_filter_queries (List[dict]): List of filter queries to identify items.\n\n    Returns:\n        DeleteResult: The result of the delete operation.\n    \"\"\"\n    return await self.repository.delete_many(key_filter_queries)\n</code></pre>"},{"location":"api/utils/constraints/const_manager/","title":"const_manager","text":"<p>This module provides utilities for creating constrained string types using Pydantic.</p> <p>Functions:</p> Name Description <code>create_constrained_string</code> <p>Creates a constrained string type with specified minimum and maximum lengths.</p>"},{"location":"api/utils/constraints/const_manager/#pydaadop.utils.constraints.const_manager.create_constrained_string","title":"create_constrained_string","text":"<pre><code>create_constrained_string() -&gt; constr\n</code></pre> <p>Creates a constrained string type with specified minimum and maximum lengths.</p> <p>This function uses the <code>constr</code> type from Pydantic to create a string type that enforces minimum and maximum length constraints.</p> <p>Returns:</p> Name Type Description <code>constr</code> <code>constr</code> <p>A constrained string type.</p> Example <p>ConstrainedStr = create_constrained_string() ConstrainedStr('example')  # Valid if 'example' meets length constraints 'example'</p> Source code in <code>src/pydaadop/utils/constraints/const_manager.py</code> <pre><code>def create_constrained_string() -&gt; constr:\n    \"\"\"\n    Creates a constrained string type with specified minimum and maximum lengths.\n\n    This function uses the `constr` type from Pydantic to create a string type\n    that enforces minimum and maximum length constraints.\n\n    Returns:\n        constr: A constrained string type.\n\n    Example:\n        &gt;&gt;&gt; ConstrainedStr = create_constrained_string()\n        &gt;&gt;&gt; ConstrainedStr('example')  # Valid if 'example' meets length constraints\n        'example'\n    \"\"\"\n    return constr(min_length=MIN_STRING_LENGTH, max_length=MAX_STRING_LENGTH)\n</code></pre>"},{"location":"api/utils/environment/env_manager/","title":"env_manager","text":"<p>This module provides utilities for managing environment variables related to MongoDB connections.</p> <p>Functions:</p> Name Description <code>get_mongo_uri</code> <p>Constructs a MongoDB URI from environment variables.</p>"},{"location":"api/utils/environment/env_manager/#pydaadop.utils.environment.env_manager.get_mongo_uri","title":"get_mongo_uri","text":"<pre><code>get_mongo_uri() -&gt; str | None\n</code></pre> <p>Constructs a MongoDB URI from environment variables.</p> <p>This function reads the following environment variables: - MONGODB_USER: The MongoDB username. - MONGODB_PASS: The MongoDB password. - MONGO_BASE_URL: The base URL of the MongoDB server. - MONGO_PORT: The port number of the MongoDB server.</p> <p>It then constructs and returns a MongoDB URI in the format: <code>mongodb://&lt;MONGODB_USER&gt;:&lt;MONGODB_PASS&gt;@&lt;MONGO_BASE_URL&gt;:&lt;MONGO_PORT&gt;</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the required environment variables are missing.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The constructed MongoDB URI.</p> Example <p>os.environ['MONGODB_USER'] = 'user' os.environ['MONGODB_PASS'] = 'pass' os.environ['MONGO_BASE_URL'] = 'localhost' os.environ['MONGO_PORT'] = '27017' get_mongo_uri() 'mongodb://user:pass@localhost:27017'</p> Source code in <code>src/pydaadop/utils/environment/env_manager.py</code> <pre><code>def get_mongo_uri() -&gt; str | None:\n    \"\"\"\n    Constructs a MongoDB URI from environment variables.\n\n    This function reads the following environment variables:\n    - MONGODB_USER: The MongoDB username.\n    - MONGODB_PASS: The MongoDB password.\n    - MONGO_BASE_URL: The base URL of the MongoDB server.\n    - MONGO_PORT: The port number of the MongoDB server.\n\n    It then constructs and returns a MongoDB URI in the format:\n    `mongodb://&lt;MONGODB_USER&gt;:&lt;MONGODB_PASS&gt;@&lt;MONGO_BASE_URL&gt;:&lt;MONGO_PORT&gt;`\n\n    Raises:\n        ValueError: If any of the required environment variables are missing.\n\n    Returns:\n        str: The constructed MongoDB URI.\n\n    Example:\n        &gt;&gt;&gt; os.environ['MONGODB_USER'] = 'user'\n        &gt;&gt;&gt; os.environ['MONGODB_PASS'] = 'pass'\n        &gt;&gt;&gt; os.environ['MONGO_BASE_URL'] = 'localhost'\n        &gt;&gt;&gt; os.environ['MONGO_PORT'] = '27017'\n        &gt;&gt;&gt; get_mongo_uri()\n        'mongodb://user:pass@localhost:27017'\n    \"\"\"\n    # Create a dictionary for necessary variables and their values\n    env_vars = {\n        'MONGODB_USER': os.getenv('MONGODB_USER'),\n        'MONGODB_PASS': os.getenv('MONGODB_PASS'),\n        'MONGO_BASE_URL': os.getenv('MONGO_BASE_URL'),\n        'MONGO_PORT': os.getenv('MONGO_PORT')\n    }\n\n    # Check if all required variables are present\n    missing_vars = {key: value for key, value in env_vars.items() if value is None}\n\n    if missing_vars:\n        raise ValueError(f\"Missing required environment variables: {', '.join(missing_vars.keys())}\")\n\n    # Construct the MONGO_URI\n    mongo_uri = f\"mongodb://{env_vars['MONGODB_USER']}:{env_vars['MONGODB_PASS']}@\" \\\n                f\"{env_vars['MONGO_BASE_URL']}:{env_vars['MONGO_PORT']}\"\n\n    return mongo_uri\n</code></pre>"},{"location":"examples/full/","title":"Full Setup","text":""},{"location":"examples/extended/extended_overview/","title":"Quick Overview","text":"<p>In the extended version we now defining custom <code>Pydantic</code> models. Also we are extending the setup with a init script to prefill the MongoDB with some data. </p>"},{"location":"examples/extended/extended_overview/#models","title":"Models","text":"<p>We are creating a <code>GenericModel</code> as well as a <code>CustomModel</code> which is inheriting from the <code>GenericModel</code>. The <code>GenericModel</code> is inheriting from the <code>BaseMongoModel</code> which itself is a <code>Pydantic</code>  base model. Also we are defining a <code>MyDefinition</code> enum.</p> <p>The <code>CustomModel</code> is overriding the <code>create_index</code> method to create an individual index for the <code>GenericModel</code> using the <code>date_value</code> + <code>test_enum</code> field. With that we are able to query the data more efficiently.</p> <pre><code>\nclassDiagram\n    direction LR\n    class BaseMongoModel {\n        id: ObjectId\n    }\n    class GenericModel {\n        str_value: str\n        int_value: int\n        float_value: float\n        date_value: datetime\n        test_enum: MyDefinition\n    }\n    class CustomModel {\n        create_index()\n    }\n    class MyDefinition {\n        - A\n        - B\n        - C\n    }\n\n    BaseMongoModel &lt;|-- GenericModel\n    GenericModel &lt;|-- CustomModel\n    MyDefinition &lt;-- GenericModel</code></pre>"},{"location":"examples/extended/extended_overview/#architecture","title":"Architecture","text":"<p>The following component architecture will be created inside a Docker container. The FastAPI will be accessible via <code>http://localhost:8000</code> and the Swagger UI via <code>http://localhost:8000/docs</code>. The access to the MongoDB will be handled by the FastAPI. In addition we now have a <code>Init</code> container which will run once and prefill the MongoDB with some data by calling the FastAPI.</p> <pre><code>architecture-beta\n    group api(cloud)[Docker]\n\n    service db(database)[MongoDb] in api\n    service server(server)[FastAPI] in api\n    service init(server)[Init] in api\n    service swagger(internet)[Swagger UI] in api\n\n    db:L -- R:server\n    init:R -- L:server\n    swagger:T -- B:server\n</code></pre>"},{"location":"examples/extended/extended_overview/#endpoints","title":"Endpoints","text":"<p>In this example we will use the defined classes to provide ReadWrite-Endpoints for the <code>GenericModel</code> and ManyReadWrite-Endpoints for the <code>CustomModel</code> via FastAPI.</p>"},{"location":"examples/extended/extended_run/","title":"Extended Setup Run","text":"<p>Info</p> <p>After the Extended Setup you should be able to test and run the setup.</p> <p>Warning</p> <p>Make sure that you have docker installed in your environment. Else follow the instructions on the Docker website.</p> <p>Run the docker-compose file to create docker containers. With this command the <code>example.env</code> file is used to set the environment variables and a build is forced.</p> <pre><code>docker-compose --env-file example.env up --build\n</code></pre>"},{"location":"examples/extended/extended_run/#open-the-swagger-ui","title":"Open the Swagger UI","text":"<p>Visit the Swagger UI in your Browser. The following Swagger UI should be automatically be generated providing different basic read-write endpoints for the <code>BaseMongoModel</code> which are provided by the FastAPI.</p>"},{"location":"examples/extended/extended_run/#create-a-new-document","title":"Create a new document","text":"Swagger UICurl <p>Click on the <code>POST</code> endpoint and then on the <code>Try it out</code> button. Fill in the <code>body</code> with the following content and click on the <code>Execute</code> button.</p> <pre><code>{\n\"_id\": \"11111111-2222-3333-4444-555555555555\"\n}\n</code></pre> <pre><code>curl -X 'POST' \\\n'http://localhost:8000/basemongomodel/' \\\n-H 'accept: application/json' \\\n-H 'Content-Type: application/json' \\\n-d '{\n\"_id\": \"11111111-2222-3333-4444-555555555555\"\n}'\n</code></pre> <p>The response should be similar to the following:</p> <pre><code>{\n  \"_id\": \"11111111-2222-3333-4444-555555555555\"\n}\n</code></pre> <p>Feel free to test and play with the other endpoints as well.</p>"},{"location":"examples/extended/extended_setup/","title":"Quick Setup","text":"<p>We are using a pre-defined release which is ready to go to keep it simple and fast. </p>"},{"location":"examples/extended/extended_setup/#download","title":"Download","text":"<p>To get all files either visit and clone the Branch or just download the Archive. Extract the files to your desired location.</p>"},{"location":"examples/extended/extended_setup/#open","title":"Open","text":"<p>Open the extracted folder in your favorite IDE like VS Code or PyCharm. You can also just use the terminal in the root of the project.</p>"},{"location":"examples/extended/extended_setup/#next","title":"Next","text":"<p>Now you should have a working setup! \ud83d\ude80</p> <p>Tip</p> <p>On the Extended Setup Run page you get some tips how to test if everything worked as expected.</p>"},{"location":"examples/quick/quick_overview/","title":"Quick Overview","text":"<p>This is the easiest way to get started with <code>pydaadop</code>. We are using mostly hard-coded values to create a ReadWrite FastAPI application with a MongoDB backend. You will be able to access (read / write) the data from the MongoDB using the FastAPI via Swagger UI.</p>"},{"location":"examples/quick/quick_overview/#architecture","title":"Architecture","text":"<p>The following component architecture will be created inside a Docker container. The FastAPI will be accessible via <code>http://localhost:8000</code> and the Swagger UI via <code>http://localhost:8000/docs</code>. The access to the MongoDB will be handled by the FastAPI.</p> <pre><code>architecture-beta\n    group api(cloud)[Docker]\n\n    service db(database)[MongoDb] in api\n    service server(server)[FastAPI] in api\n    service swagger(internet)[Swagger UI] in api\n\n    db:L -- R:server\n    swagger:T -- B:server\n</code></pre>"},{"location":"examples/quick/quick_overview/#endpoints","title":"Endpoints","text":"<p>In this example we will use the provided <code>BaseMongoModel</code> to create ReadWrite endpoints for the MongoDB via FastAPI.</p>"},{"location":"examples/quick/quick_run/","title":"Quick Setup Run","text":"<p>Info</p> <p>After the Quick Setup you should be able to test and run the setup.</p> <p>Warning</p> <p>Make sure that you have docker installed in your environment. Else follow the instructions on the Docker website.</p> <p>Run the docker-compose file to create docker containers. With this command the <code>example.env</code> file is used to set the environment variables and a build is forced.</p> <pre><code>docker-compose --env-file example.env up --build\n</code></pre>"},{"location":"examples/quick/quick_run/#open-the-swagger-ui","title":"Open the Swagger UI","text":"<p>Visit the Swagger UI in your Browser. The following Swagger UI should be automatically be generated providing different basic read-write endpoints for the <code>BaseMongoModel</code> which are provided by the FastAPI.</p>"},{"location":"examples/quick/quick_run/#create-a-new-document","title":"Create a new document","text":"Swagger UICurl <p>Click on the <code>POST</code> endpoint and then on the <code>Try it out</code> button. Fill in the <code>body</code> with the following content and click on the <code>Execute</code> button.</p> <pre><code>{\n\"_id\": \"11111111-2222-3333-4444-555555555555\"\n}\n</code></pre> <pre><code>curl -X 'POST' \\\n'http://localhost:8000/basemongomodel/' \\\n-H 'accept: application/json' \\\n-H 'Content-Type: application/json' \\\n-d '{\n\"_id\": \"11111111-2222-3333-4444-555555555555\"\n}'\n</code></pre> <p>The response should be similar to the following:</p> <pre><code>{\n  \"_id\": \"11111111-2222-3333-4444-555555555555\"\n}\n</code></pre> <p>Feel free to test and play with the other endpoints as well.</p>"},{"location":"examples/quick/quick_setup/","title":"Quick Setup","text":"<p>You can either choose the ready-to-go project or setup the project manually to get to know the basics components of a <code>pydaadop</code> project.</p> Read-to-go SetupManual Setup <p>We are using a pre-defined release which is ready to go.</p> <p>We are setting up all files which are needed for a minimalistic pydaadop project.</p>"},{"location":"examples/quick/quick_setup/#1-download","title":"1. Download","text":"<p>To get all files either visit and clone the Branch or just download the Archive. Extract the files to your desired location.</p>"},{"location":"examples/quick/quick_setup/#2-open","title":"2. Open","text":"<p>Open the extracted folder in your favorite IDE like VS Code or PyCharm. You can also just use the terminal in the root of the project.</p>"},{"location":"examples/quick/quick_setup/#1-install","title":"1. Install","text":"<p>Follow the installation instructions to install Pydaadop in your environment. Make sure that you have docker installed in your environment.</p>"},{"location":"examples/quick/quick_setup/#2-setup","title":"2. Setup","text":"<p>Create a new project in your favorite IDE like VS Code or PyCharm.</p>"},{"location":"examples/quick/quick_setup/#21-environment-variables","title":"2.1 Environment Variables","text":"<p>Warning</p> <p>Naming the file <code>.env</code> is a common practice and it's not recommended to change it and even worse to commit it to the repository. We use the <code>example.env</code> file to be able to commit it to the repository using no actual sensitive data.</p> <p>Create a <code>example.env</code> file in the root of your project and add the following environment variables. Feel free to adjust the actual values to your needs.</p> .env<pre><code># MongoDB credentials\nMONGODB_USER=pydaadop_example\nMONGODB_PASS=MyPydaadopExamplePassword\n\n# MongoDB connection details\nMONGO_PORT=27018\nMONGO_BASE_URL=pydaadop-quick-example-mongo\n</code></pre>"},{"location":"examples/quick/quick_setup/#22-requirements","title":"2.2 Requirements","text":"<p>Create a <code>requirements.txt</code> file in the root of your project and add <code>pydaadop</code>.</p> requirements.txt<pre><code>git+https://github.com/vanthomiy/pydaadop@main\n</code></pre>"},{"location":"examples/quick/quick_setup/#23-api","title":"2.3 API","text":"<p>Add a new file <code>api.py</code> and define the <code>Fast API</code> using the <code>BaseReadRouter</code> class.</p> api.py<pre><code>from fastapi import FastAPI\nimport uvicorn\nfrom pydaadop.routes.base.base_read_write_route import BaseReadWriteRouter\nfrom pydaadop.models.base.base_mongo_model import BaseMongoModel\n\n# Create FastAPI app\napp = FastAPI()\n# Include a base read router of type BaseMongoModel\napp.include_router(BaseReadWriteRouter(BaseMongoModel).router)\n\n# Run the app\nif __name__ == \"__main__\":\n    uvicorn.run(app)\n</code></pre>"},{"location":"examples/quick/quick_setup/#24-docker","title":"2.4 Docker","text":"<p>We need to add a <code>Dockerfile</code> and a <code>docker-compose.yml</code> file to the root of the project. These will dockerize the FastAPI and MongoDB for easy setup.</p> api.Dockerfile<pre><code># Base image: Python 3.10\nFROM python:3.10-slim\n\n# Install git and other dependencies\nRUN apt-get update &amp;&amp; apt-get install -y git &amp;&amp; apt-get clean\n\n# Retrieve the expected environment variables\nARG FAST_API_BASE_URL\nARG FAST_API_PORT\n\n# Set working directory in the container\nWORKDIR /app\n\n# Copy requirements.txt into the container\nCOPY requirements.txt .\n\n# Install the required Python packages\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy the example.env file into the container\nCOPY example.env .env\n\n# Copy the api.py file into the container\nCOPY api.py .\n\n# Expose the port the FastAPI app will run on\nEXPOSE ${FAST_API_PORT}\n\nWORKDIR /app\n\n# Command to run FastAPI using uvicorn\nCMD [\"sh\", \"-c\", \"uvicorn api:app --host 0.0.0.0 --port 8000\"]\n</code></pre> docker-compose.yml<pre><code>services:\n  extended-setup-api:\n    build:\n      context: .\n      dockerfile: api.Dockerfile\n    container_name: pydaadop-quick-example-api\n    ports:\n      - 8000:8000\n    env_file:\n      - example.env\n    networks:\n      - pydaadop-quick-example-network\n\n  quick-setup-mongo:\n    image: mongo:latest\n    command: mongod --port ${MONGO_PORT}\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: ${MONGODB_USER}\n      MONGO_INITDB_ROOT_PASSWORD: ${MONGODB_PASS}\n    container_name: pydaadop-quick-example-mongo\n    ports:\n      - \"${MONGO_PORT}:${MONGO_PORT}\"  # Expose MongoDB on port\n    volumes:\n      - mongo_data:/data/db  # Persist MongoDB data\n    networks:\n      - pydaadop-quick-example-network\n\nvolumes:\n  mongo_data: # Define a named volume for MongoDB data persistence\n\nnetworks:\n  pydaadop-quick-example-network:\n    driver: bridge  # Define the network with a driver\n</code></pre>"},{"location":"examples/quick/quick_setup/#3-final-project","title":"3. Final Project","text":"<p>Our final project should look like this:</p> <pre><code>.\n\u251c\u2500\u2500 api.py\n\u251c\u2500\u2500 api.Dockerfile\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 example.env\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"examples/quick/quick_setup/#next-test-and-run-your-setup","title":"Next test and run your setup","text":"<p>Now you should have a working setup! \ud83d\ude80</p> <p>Tip</p> <p>On the Quick Setup Run page you get some tips how to test if everything worked as expected.</p>"}]}